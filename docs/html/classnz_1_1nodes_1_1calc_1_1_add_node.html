<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NeuZephyr: nz::nodes::calc::AddNode Class Reference</title>
<link rel="icon" href="NZ_logo2.png" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="NZ_logo2.png"/></td>
  <td id="projectalign">
   <div id="projectname">NeuZephyr
   </div>
   <div id="projectbrief">Simple DL Framework</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>nz</b></li><li class="navelem"><a class="el" href="namespacenz_1_1nodes.html">nodes</a></li><li class="navelem"><a class="el" href="namespacenz_1_1nodes_1_1calc.html">calc</a></li><li class="navelem"><a class="el" href="classnz_1_1nodes_1_1calc_1_1_add_node.html">AddNode</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classnz_1_1nodes_1_1calc_1_1_add_node-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">nz::nodes::calc::AddNode Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Represents a node that performs element-wise addition between two input tensors.  
 <a href="#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for nz::nodes::calc::AddNode:</div>
<div class="dyncontent">
<div class="center"><img src="classnz_1_1nodes_1_1calc_1_1_add_node__inherit__graph.png" border="0" usemap="#anz_1_1nodes_1_1calc_1_1_add_node_inherit__map" alt="Inheritance graph"/></div>
<map name="anz_1_1nodes_1_1calc_1_1_add_node_inherit__map" id="anz_1_1nodes_1_1calc_1_1_add_node_inherit__map">
<area shape="rect" title="Represents a node that performs element&#45;wise addition between two input tensors." alt="" coords="5,80,178,107"/>
<area shape="rect" href="classnz_1_1nodes_1_1_node.html" title="Base class for nodes in a neural network or computational graph." alt="" coords="33,5,150,32"/>
<area shape="poly" title=" " alt="" coords="94,48,94,80,89,80,89,48"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for nz::nodes::calc::AddNode:</div>
<div class="dyncontent">
<div class="center"><img src="classnz_1_1nodes_1_1calc_1_1_add_node__coll__graph.png" border="0" usemap="#anz_1_1nodes_1_1calc_1_1_add_node_coll__map" alt="Collaboration graph"/></div>
<map name="anz_1_1nodes_1_1calc_1_1_add_node_coll__map" id="anz_1_1nodes_1_1calc_1_1_add_node_coll__map">
<area shape="rect" title="Represents a node that performs element&#45;wise addition between two input tensors." alt="" coords="5,80,178,107"/>
<area shape="rect" href="classnz_1_1nodes_1_1_node.html" title="Base class for nodes in a neural network or computational graph." alt="" coords="33,5,150,32"/>
<area shape="poly" title=" " alt="" coords="94,48,94,80,89,80,89,48"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:abf5d0c2b9827bfb8fd1f3a004db80175" id="r_abf5d0c2b9827bfb8fd1f3a004db80175"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abf5d0c2b9827bfb8fd1f3a004db80175">AddNode</a> (<a class="el" href="classnz_1_1nodes_1_1_node.html">Node</a> *input_left, <a class="el" href="classnz_1_1nodes_1_1_node.html">Node</a> *input_right)</td></tr>
<tr class="memdesc:abf5d0c2b9827bfb8fd1f3a004db80175"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor to initialize an <code><a class="el" href="classnz_1_1nodes_1_1calc_1_1_add_node.html" title="Represents a node that performs element-wise addition between two input tensors.">AddNode</a></code> with two input nodes for element-wise addition.  <br /></td></tr>
<tr class="separator:abf5d0c2b9827bfb8fd1f3a004db80175"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcbcffc97ede105ec64c7360377b9af3" id="r_adcbcffc97ede105ec64c7360377b9af3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adcbcffc97ede105ec64c7360377b9af3">forward</a> () override</td></tr>
<tr class="memdesc:adcbcffc97ede105ec64c7360377b9af3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward pass for the <code><a class="el" href="classnz_1_1nodes_1_1calc_1_1_add_node.html" title="Represents a node that performs element-wise addition between two input tensors.">AddNode</a></code> to perform element-wise addition.  <br /></td></tr>
<tr class="separator:adcbcffc97ede105ec64c7360377b9af3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacd0de4600132791c8da7860dba3e43c" id="r_aacd0de4600132791c8da7860dba3e43c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aacd0de4600132791c8da7860dba3e43c">backward</a> () override</td></tr>
<tr class="memdesc:aacd0de4600132791c8da7860dba3e43c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Backward pass for the <code><a class="el" href="classnz_1_1nodes_1_1calc_1_1_add_node.html" title="Represents a node that performs element-wise addition between two input tensors.">AddNode</a></code> to propagate gradients.  <br /></td></tr>
<tr class="separator:aacd0de4600132791c8da7860dba3e43c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classnz_1_1nodes_1_1_node"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_methods_classnz_1_1nodes_1_1_node')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classnz_1_1nodes_1_1_node.html">nz::nodes::Node</a></td></tr>
<tr class="memitem:a687ee9c34eb61f8f28caa201ca42696e inherit pub_methods_classnz_1_1nodes_1_1_node" id="r_a687ee9c34eb61f8f28caa201ca42696e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnz_1_1nodes_1_1_node.html#a687ee9c34eb61f8f28caa201ca42696e">print</a> (std::ostream &amp;os) const</td></tr>
<tr class="memdesc:a687ee9c34eb61f8f28caa201ca42696e inherit pub_methods_classnz_1_1nodes_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the type, data, and gradient of the node.  <br /></td></tr>
<tr class="separator:a687ee9c34eb61f8f28caa201ca42696e inherit pub_methods_classnz_1_1nodes_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b85913e12422bb4ac2fff483427bb47 inherit pub_methods_classnz_1_1nodes_1_1_node" id="r_a9b85913e12422bb4ac2fff483427bb47"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnz_1_1nodes_1_1_node.html#a9b85913e12422bb4ac2fff483427bb47">dataInject</a> (Tensor::value_type *data, bool grad=false) const</td></tr>
<tr class="memdesc:a9b85913e12422bb4ac2fff483427bb47 inherit pub_methods_classnz_1_1nodes_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Injects data into a relevant tensor object, optionally setting its gradient requirement.  <br /></td></tr>
<tr class="separator:a9b85913e12422bb4ac2fff483427bb47 inherit pub_methods_classnz_1_1nodes_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a609f1730085dd1d31e0ddcbbae48a065 inherit pub_methods_classnz_1_1nodes_1_1_node" id="r_a609f1730085dd1d31e0ddcbbae48a065"><td class="memTemplParams" colspan="2">template&lt;typename Iterator &gt; </td></tr>
<tr class="memitem:a609f1730085dd1d31e0ddcbbae48a065 inherit pub_methods_classnz_1_1nodes_1_1_node"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classnz_1_1nodes_1_1_node.html#a609f1730085dd1d31e0ddcbbae48a065">dataInject</a> (Iterator begin, Iterator end, const bool grad=false) const</td></tr>
<tr class="memdesc:a609f1730085dd1d31e0ddcbbae48a065 inherit pub_methods_classnz_1_1nodes_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Injects data from an iterator range into the output tensor of the InputNode, optionally setting its gradient requirement.  <br /></td></tr>
<tr class="separator:a609f1730085dd1d31e0ddcbbae48a065 inherit pub_methods_classnz_1_1nodes_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8b4bab3271df92ca1f0914f7a97b1e8 inherit pub_methods_classnz_1_1nodes_1_1_node" id="r_af8b4bab3271df92ca1f0914f7a97b1e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnz_1_1nodes_1_1_node.html#af8b4bab3271df92ca1f0914f7a97b1e8">dataInject</a> (const std::initializer_list&lt; Tensor::value_type &gt; &amp;data, bool grad=false) const</td></tr>
<tr class="memdesc:af8b4bab3271df92ca1f0914f7a97b1e8 inherit pub_methods_classnz_1_1nodes_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Injects data from a std::initializer_list into the output tensor of the <a class="el" href="classnz_1_1nodes_1_1_node.html" title="Base class for nodes in a neural network or computational graph.">Node</a>, optionally setting its gradient requirement.  <br /></td></tr>
<tr class="separator:af8b4bab3271df92ca1f0914f7a97b1e8 inherit pub_methods_classnz_1_1nodes_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Represents a node that performs element-wise addition between two input tensors. </p>
<p>The <code><a class="el" href="classnz_1_1nodes_1_1calc_1_1_add_node.html" title="Represents a node that performs element-wise addition between two input tensors.">AddNode</a></code> class is a computational node that performs element-wise addition between two input tensors during the forward pass. It also handles the backpropagation of gradients during the backward pass, propagating the gradient of the output tensor back to both input tensors. This node is typically used to represent addition operations in neural network computations.</p>
<p>Key features:</p><ul>
<li><b>Forward Pass</b>: The <code><a class="el" href="#adcbcffc97ede105ec64c7360377b9af3" title="Forward pass for the AddNode to perform element-wise addition.">forward()</a></code> method performs element-wise addition of the two input tensors and stores the result in the <code>output</code> tensor.</li>
<li><b>Backward Pass</b>: The <code><a class="el" href="#aacd0de4600132791c8da7860dba3e43c" title="Backward pass for the AddNode to propagate gradients.">backward()</a></code> method propagates the gradient of the output tensor to both input tensors by copying the gradient of the output to the gradients of the inputs.</li>
<li><b>Shape Check</b>: The constructor checks that the shapes of the two input tensors are the same, as element-wise addition requires matching shapes.</li>
</ul>
<p>This class is part of the <code><a class="el" href="namespacenz_1_1nodes.html" title="Contains classes and functionality for nodes in a neural network or computational graph.">nz::nodes</a></code> namespace and is designed for use in a computational graph where addition operations are needed.</p>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>The <code><a class="el" href="classnz_1_1nodes_1_1calc_1_1_add_node.html" title="Represents a node that performs element-wise addition between two input tensors.">AddNode</a></code> is specifically for element-wise addition. The shapes of the input tensors must match.</li>
<li>During the backward pass, the gradient of the output is distributed equally to both inputs.</li>
</ul>
</dd></dl>
<h3><a class="anchor" id="autotoc_md89"></a>
Usage Example:</h3>
<div class="fragment"><div class="line"><span class="comment">// Example 1: Creating and using an AddNode</span></div>
<div class="line">InputNode input1({3, 3}, <span class="keyword">true</span>);  <span class="comment">// Create the first input node with shape {3, 3}</span></div>
<div class="line">input1.output-&gt;fill(1.0f);  <span class="comment">// Fill the tensor with value 1.0</span></div>
<div class="line"> </div>
<div class="line">InputNode input2({3, 3}, <span class="keyword">true</span>);  <span class="comment">// Create the second input node with shape {3, 3}</span></div>
<div class="line">input2.output-&gt;fill(2.0f);  <span class="comment">// Fill the tensor with value 2.0</span></div>
<div class="line"> </div>
<div class="line"><a class="code hl_function" href="#abf5d0c2b9827bfb8fd1f3a004db80175">AddNode</a> add_node(&amp;input1, &amp;input2);  <span class="comment">// Create an AddNode using the two input nodes</span></div>
<div class="line">add_node.forward();  <span class="comment">// Perform the forward pass: output = input1 + input2</span></div>
<div class="line">add_node.backward();  <span class="comment">// Perform the backward pass: propagate gradients</span></div>
<div class="line"> </div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Output: &quot;</span> &lt;&lt; *add_node.output &lt;&lt; std::endl;  <span class="comment">// Print the output tensor</span></div>
<div class="ttc" id="aclassnz_1_1nodes_1_1calc_1_1_add_node_html_abf5d0c2b9827bfb8fd1f3a004db80175"><div class="ttname"><a href="#abf5d0c2b9827bfb8fd1f3a004db80175">nz::nodes::calc::AddNode::AddNode</a></div><div class="ttdeci">AddNode(Node *input_left, Node *input_right)</div><div class="ttdoc">Constructor to initialize an AddNode with two input nodes for element-wise addition.</div><div class="ttdef"><b>Definition</b> <a href="_nodes_8cu_source.html#l00079">Nodes.cu:79</a></div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#adcbcffc97ede105ec64c7360377b9af3" title="Forward pass for the AddNode to perform element-wise addition.">forward()</a> for the <a class="el" href="#adcbcffc97ede105ec64c7360377b9af3" title="Forward pass for the AddNode to perform element-wise addition.">forward</a> pass computation method. </dd>
<dd>
<a class="el" href="#aacd0de4600132791c8da7860dba3e43c" title="Backward pass for the AddNode to propagate gradients.">backward()</a> for the <a class="el" href="#aacd0de4600132791c8da7860dba3e43c" title="Backward pass for the AddNode to propagate gradients.">backward</a> pass gradient propagation method.</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Mgepahmge (<a href="https://github.com/Mgepahmge">https://github.com/Mgepahmge</a>)</dd></dl>
<dl class="section date"><dt>Date</dt><dd>2024/11/29 </dd></dl>

<p class="definition">Definition at line <a class="el" href="_nodes_8cuh_source.html#l00917">917</a> of file <a class="el" href="_nodes_8cuh_source.html">Nodes.cuh</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="abf5d0c2b9827bfb8fd1f3a004db80175" name="abf5d0c2b9827bfb8fd1f3a004db80175"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf5d0c2b9827bfb8fd1f3a004db80175">&#9670;&#160;</a></span>AddNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">nz::nodes::calc::AddNode::AddNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnz_1_1nodes_1_1_node.html">Node</a> *</td>          <td class="paramname"><span class="paramname"><em>input_left</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classnz_1_1nodes_1_1_node.html">Node</a> *</td>          <td class="paramname"><span class="paramname"><em>input_right</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor to initialize an <code><a class="el" href="classnz_1_1nodes_1_1calc_1_1_add_node.html" title="Represents a node that performs element-wise addition between two input tensors.">AddNode</a></code> with two input nodes for element-wise addition. </p>
<p>The constructor initializes an <code><a class="el" href="classnz_1_1nodes_1_1calc_1_1_add_node.html" title="Represents a node that performs element-wise addition between two input tensors.">AddNode</a></code> that performs element-wise addition between the outputs of two input nodes. It ensures that the shapes of the two input tensors are compatible for the addition operation. If the shapes of the two input tensors do not match, an exception is thrown. The constructor also sets up the output tensor and determines whether gradients need to be tracked based on the inputs' <code>requiresGrad</code> property.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input_left</td><td>A pointer to the first input node. Its <code>output</code> tensor is used in the addition operation. </td></tr>
    <tr><td class="paramname">input_right</td><td>A pointer to the second input node. Its <code>output</code> tensor is used in the addition operation.</td></tr>
  </table>
  </dd>
</dl>
<p>The constructor verifies that the two input tensors have the same shape, and initializes the <code>output</code> tensor with the same shape as the inputs. The <code>requires_grad</code> flag for the output tensor is set to <code>true</code> if either of the input tensors requires gradients.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>If the shapes of the input tensors do not match.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>The constructor checks for shape compatibility between the two input tensors, and if the shapes do not match, it throws an exception to prevent invalid operations.</li>
<li>The <code>output</code> tensor is created with the same shape as the input tensors, and will track gradients if any of the input tensors require them.</li>
</ul>
</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Mgepahmge (<a href="https://github.com/Mgepahmge">https://github.com/Mgepahmge</a>)</dd></dl>
<dl class="section date"><dt>Date</dt><dd>2024/11/29 </dd></dl>

<p class="definition">Definition at line <a class="el" href="_nodes_8cu_source.html#l00079">79</a> of file <a class="el" href="_nodes_8cu_source.html">Nodes.cu</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aacd0de4600132791c8da7860dba3e43c" name="aacd0de4600132791c8da7860dba3e43c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacd0de4600132791c8da7860dba3e43c">&#9670;&#160;</a></span>backward()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nz::nodes::calc::AddNode::backward </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Backward pass for the <code><a class="el" href="classnz_1_1nodes_1_1calc_1_1_add_node.html" title="Represents a node that performs element-wise addition between two input tensors.">AddNode</a></code> to propagate gradients. </p>
<p>The <code><a class="el" href="#aacd0de4600132791c8da7860dba3e43c" title="Backward pass for the AddNode to propagate gradients.">backward()</a></code> method propagates the gradient of the <code>output</code> tensor to the gradients of the two input tensors during the backward pass. Since addition is an element-wise operation, the gradient of the output is propagated equally to both input tensors.</p>
<p>If either of the input tensors requires gradients (i.e., its <code>requiresGrad()</code> method returns <code>true</code>), the gradient of the output tensor (<code>output-&gt;grad()</code>) is copied to the gradient of the corresponding input tensor. This is done using <code>cudaMemcpy</code> to efficiently propagate the gradients on the GPU.</p>
<p>This method is typically called during the backpropagation step of neural network training, where gradients are propagated backward through the network, starting from the output layer.</p>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>The gradient of the output tensor is propagated to both input tensors, and each input receives the exact same gradient as the output.</li>
<li>This method does not compute gradients for the output tensor itself. It simply propagates the gradient from the output to the inputs.</li>
<li>The gradients are copied using <code>cudaMemcpy</code> to ensure efficient GPU-based gradient propagation.</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#adcbcffc97ede105ec64c7360377b9af3" title="Forward pass for the AddNode to perform element-wise addition.">forward()</a> for the <a class="el" href="#adcbcffc97ede105ec64c7360377b9af3" title="Forward pass for the AddNode to perform element-wise addition.">forward</a> pass computation method.</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Mgepahmge (<a href="https://github.com/Mgepahmge">https://github.com/Mgepahmge</a>)</dd></dl>
<dl class="section date"><dt>Date</dt><dd>2024/11/29 </dd></dl>

<p>Implements <a class="el" href="classnz_1_1nodes_1_1_node.html#a0a9ecbaa3d790ba38e8218aca7837fd0">nz::nodes::Node</a>.</p>

<p class="definition">Definition at line <a class="el" href="_nodes_8cu_source.html#l00099">99</a> of file <a class="el" href="_nodes_8cu_source.html">Nodes.cu</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classnz_1_1nodes_1_1calc_1_1_add_node_aacd0de4600132791c8da7860dba3e43c_cgraph.png" border="0" usemap="#aclassnz_1_1nodes_1_1calc_1_1_add_node_aacd0de4600132791c8da7860dba3e43c_cgraph" alt=""/></div>
<map name="aclassnz_1_1nodes_1_1calc_1_1_add_node_aacd0de4600132791c8da7860dba3e43c_cgraph" id="aclassnz_1_1nodes_1_1calc_1_1_add_node_aacd0de4600132791c8da7860dba3e43c_cgraph">
<area shape="rect" title="Backward pass for the AddNode to propagate gradients." alt="" coords="5,135,178,177"/>
<area shape="rect" href="namespacenz_1_1krnl.html#a0ed44a68bfb86a9fd3d6c3b25614713f" title="Copies gradient data from one array to another with specified offsets." alt="" coords="254,143,382,169"/>
<area shape="poly" title=" " alt="" coords="178,153,239,153,239,159,178,159"/>
<area shape="rect" href="classnz_1_1cu_strm_1_1_stream_manager.html#ab4b2eb422e0e1ee44bdfdc0eb94457ce" title="Returns a reference to the singleton instance of the StreamManager." alt="" coords="459,205,644,248"/>
<area shape="poly" title=" " alt="" coords="179,170,226,179,444,210,443,216,225,184,178,176"/>
<area shape="rect" href="classnz_1_1cu_strm_1_1_stream_manager.html#afa38d5c6db0e6b48c8f74ce8ad0df2bc" title="Asynchronously copies data between CUDA device and host memory based on the specified memory copy kin..." alt="" coords="226,72,411,115"/>
<area shape="poly" title=" " alt="" coords="171,132,223,117,225,122,172,137"/>
<area shape="rect" href="classnz_1_1cu_strm_1_1_stream_manager.html#a1de1cf3aadea137faf90a2f9b4b7abe2" title="Acquires CUDA stream from pool using round&#45;robin scheduling." alt="" coords="459,5,644,48"/>
<area shape="poly" title=" " alt="" coords="380,140,409,125,425,109,433,92,441,75,457,58,463,54,466,58,461,62,446,78,438,95,429,112,413,129,383,144"/>
<area shape="poly" title=" " alt="" coords="366,167,465,198,464,203,364,173"/>
<area shape="rect" href="classnz_1_1cu_strm_1_1_stream_manager.html#a1260d95d0eddf75b72700da07361a4bd" title="Records write completion event for asynchronous data operations." alt="" coords="459,139,644,181"/>
<area shape="poly" title=" " alt="" coords="383,154,443,155,443,161,383,160"/>
<area shape="rect" href="classnz_1_1cu_strm_1_1_stream_manager.html#adb1078a67c6e38932d7d58c2adb05ec0" title="Synchronizes CUDA stream execution until data writes complete." alt="" coords="459,72,644,115"/>
<area shape="poly" title=" " alt="" coords="370,140,454,117,456,122,372,145"/>
<area shape="poly" title=" " alt="" coords="394,69,459,50,460,55,396,74"/>
<area shape="poly" title=" " alt="" coords="411,91,443,91,443,96,411,96"/>
</map>
</div>

</div>
</div>
<a id="adcbcffc97ede105ec64c7360377b9af3" name="adcbcffc97ede105ec64c7360377b9af3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcbcffc97ede105ec64c7360377b9af3">&#9670;&#160;</a></span>forward()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nz::nodes::calc::AddNode::forward </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Forward pass for the <code><a class="el" href="classnz_1_1nodes_1_1calc_1_1_add_node.html" title="Represents a node that performs element-wise addition between two input tensors.">AddNode</a></code> to perform element-wise addition. </p>
<p>The <code><a class="el" href="#adcbcffc97ede105ec64c7360377b9af3" title="Forward pass for the AddNode to perform element-wise addition.">forward()</a></code> method performs the element-wise addition between the two input tensors and stores the result in the <code>output</code> tensor. It uses CUDA kernel <code>MatrixAddKernel</code> to carry out the addition operation efficiently on the GPU.</p>
<p>This method is called during the forward pass of the neural network, where it computes the sum of the two input tensors and assigns the result to the <code>output</code> tensor. The shape of the <code>output</code> tensor will be the same as the shape of the input tensors, as verified during the initialization of the <code><a class="el" href="classnz_1_1nodes_1_1calc_1_1_add_node.html" title="Represents a node that performs element-wise addition between two input tensors.">AddNode</a></code>.</p>
<p>The method divides the work into blocks and grids to parallelize the addition operation over the GPU.</p>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>The <code>MatrixAdd</code> kernel performs the addition operation on the GPU, ensuring efficient parallel computation.</li>
<li>The <code>output</code> tensor is updated with the result of the addition, and it must be allocated before calling <code><a class="el" href="#adcbcffc97ede105ec64c7360377b9af3" title="Forward pass for the AddNode to perform element-wise addition.">forward()</a></code>.</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#aacd0de4600132791c8da7860dba3e43c" title="Backward pass for the AddNode to propagate gradients.">backward()</a> for the <a class="el" href="#aacd0de4600132791c8da7860dba3e43c" title="Backward pass for the AddNode to propagate gradients.">backward</a> pass gradient propagation method.</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Mgepahmge (<a href="https://github.com/Mgepahmge">https://github.com/Mgepahmge</a>)</dd></dl>
<dl class="section date"><dt>Date</dt><dd>2024/11/29 </dd></dl>

<p>Implements <a class="el" href="classnz_1_1nodes_1_1_node.html#a8a828c2e91a4aa2a9ab7b94554e4685b">nz::nodes::Node</a>.</p>

<p class="definition">Definition at line <a class="el" href="_nodes_8cu_source.html#l00095">95</a> of file <a class="el" href="_nodes_8cu_source.html">Nodes.cu</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classnz_1_1nodes_1_1calc_1_1_add_node_adcbcffc97ede105ec64c7360377b9af3_cgraph.png" border="0" usemap="#aclassnz_1_1nodes_1_1calc_1_1_add_node_adcbcffc97ede105ec64c7360377b9af3_cgraph" alt=""/></div>
<map name="aclassnz_1_1nodes_1_1calc_1_1_add_node_adcbcffc97ede105ec64c7360377b9af3_cgraph" id="aclassnz_1_1nodes_1_1calc_1_1_add_node_adcbcffc97ede105ec64c7360377b9af3_cgraph">
<area shape="rect" title="Forward pass for the AddNode to perform element&#45;wise addition." alt="" coords="5,5,178,48"/>
<area shape="rect" href="namespacenz_1_1data.html#a8cf4ac2437dd67698684169bebb225d4" title="Performs matrix addition operation on tensors with broadcast compatibility." alt="" coords="226,13,397,40"/>
<area shape="poly" title=" " alt="" coords="178,24,210,24,210,29,178,29"/>
</map>
</div>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>D:/Users/Mgepahmge/Documents/C Program/NeuZephyr/include/NeuZephyr/<a class="el" href="_nodes_8cuh_source.html">Nodes.cuh</a></li>
<li>D:/Users/Mgepahmge/Documents/C Program/NeuZephyr/src/<a class="el" href="_nodes_8cu_source.html">Nodes.cu</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0
</small></address>
</div><!-- doc-content -->
</body>
</html>

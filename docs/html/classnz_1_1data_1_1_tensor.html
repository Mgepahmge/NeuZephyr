<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NeuZephyr: nz::data::Tensor Class Reference</title>
<link rel="icon" href="NZ_logo2.png" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="NZ_logo2.png"/></td>
  <td id="projectalign">
   <div id="projectname">NeuZephyr
   </div>
   <div id="projectbrief">Simple DL Framework</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>nz</b></li><li class="navelem"><a class="el" href="namespacenz_1_1data.html">data</a></li><li class="navelem"><a class="el" href="classnz_1_1data_1_1_tensor.html">Tensor</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#friends">Friends</a> &#124;
<a href="classnz_1_1data_1_1_tensor-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">nz::data::Tensor Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>A class for representing and manipulating multidimensional arrays (tensors) in GPU memory.  
 <a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructors and Destructors</div></td></tr>
<tr class="memitem:ad0dda0efff93778cab46fd5aa708b983" id="r_ad0dda0efff93778cab46fd5aa708b983"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad0dda0efff93778cab46fd5aa708b983">Tensor</a> ()</td></tr>
<tr class="memdesc:ad0dda0efff93778cab46fd5aa708b983"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor for <a class="el" href="classnz_1_1data_1_1_tensor.html" title="A class for representing and manipulating multidimensional arrays (tensors) in GPU memory.">Tensor</a>.  <br /></td></tr>
<tr class="separator:ad0dda0efff93778cab46fd5aa708b983"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a3fc1e2d0b5154cdb4961679d0752af" id="r_a6a3fc1e2d0b5154cdb4961679d0752af"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6a3fc1e2d0b5154cdb4961679d0752af">Tensor</a> (const <a class="el" href="classnz_1_1data_1_1_dimension.html">shape_type</a> &amp;<a class="el" href="#aade7b0c42622279888d755f4f7989aac">shape</a>, bool requires_grad=false)</td></tr>
<tr class="memdesc:a6a3fc1e2d0b5154cdb4961679d0752af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor that initializes a <a class="el" href="classnz_1_1data_1_1_tensor.html" title="A class for representing and manipulating multidimensional arrays (tensors) in GPU memory.">Tensor</a> with the specified shape.  <br /></td></tr>
<tr class="separator:a6a3fc1e2d0b5154cdb4961679d0752af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad65fa89fac9d72c92d34ace7e94610df" id="r_ad65fa89fac9d72c92d34ace7e94610df"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad65fa89fac9d72c92d34ace7e94610df">Tensor</a> (const <a class="el" href="classnz_1_1data_1_1_dimension.html">shape_type</a> &amp;<a class="el" href="#aade7b0c42622279888d755f4f7989aac">shape</a>, value_type *<a class="el" href="#a38ba233ef49f34620297f96edd962c55">data</a>, bool requires_grad=false, bool host=true)</td></tr>
<tr class="memdesc:ad65fa89fac9d72c92d34ace7e94610df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a <a class="el" href="classnz_1_1data_1_1_tensor.html" title="A class for representing and manipulating multidimensional arrays (tensors) in GPU memory.">Tensor</a> object with specified shape, data, gradient requirement, and data location.  <br /></td></tr>
<tr class="separator:ad65fa89fac9d72c92d34ace7e94610df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18937864a9eb48eb91a5d82ebf9c010e" id="r_a18937864a9eb48eb91a5d82ebf9c010e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a18937864a9eb48eb91a5d82ebf9c010e">Tensor</a> (const <a class="el" href="classnz_1_1data_1_1_dimension.html">shape_type</a> &amp;<a class="el" href="#aade7b0c42622279888d755f4f7989aac">shape</a>, const std::initializer_list&lt; value_type &gt; &amp;<a class="el" href="#a38ba233ef49f34620297f96edd962c55">data</a>, bool requires_grad=false)</td></tr>
<tr class="memdesc:a18937864a9eb48eb91a5d82ebf9c010e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a <a class="el" href="classnz_1_1data_1_1_tensor.html" title="A class for representing and manipulating multidimensional arrays (tensors) in GPU memory.">Tensor</a> object with a specified shape, initializer list data, and gradient requirement.  <br /></td></tr>
<tr class="separator:a18937864a9eb48eb91a5d82ebf9c010e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6184f0270420ac054f7bd372bbed1406" id="r_a6184f0270420ac054f7bd372bbed1406"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6184f0270420ac054f7bd372bbed1406">Tensor</a> (const <a class="el" href="classnz_1_1data_1_1_tensor.html">Tensor</a> &amp;other)</td></tr>
<tr class="memdesc:a6184f0270420ac054f7bd372bbed1406"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor for <a class="el" href="classnz_1_1data_1_1_tensor.html" title="A class for representing and manipulating multidimensional arrays (tensors) in GPU memory.">Tensor</a>.  <br /></td></tr>
<tr class="separator:a6184f0270420ac054f7bd372bbed1406"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb57f91ae907875d78d804de85dbbc73" id="r_adb57f91ae907875d78d804de85dbbc73"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adb57f91ae907875d78d804de85dbbc73">Tensor</a> (<a class="el" href="classnz_1_1data_1_1_tensor.html">Tensor</a> &amp;&amp;other) noexcept(false)</td></tr>
<tr class="memdesc:adb57f91ae907875d78d804de85dbbc73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor for <a class="el" href="classnz_1_1data_1_1_tensor.html" title="A class for representing and manipulating multidimensional arrays (tensors) in GPU memory.">Tensor</a>.  <br /></td></tr>
<tr class="separator:adb57f91ae907875d78d804de85dbbc73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdb68bf53d38e5a93fdd0effa4c3059a" id="r_acdb68bf53d38e5a93fdd0effa4c3059a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnz_1_1data_1_1_tensor.html">Tensor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acdb68bf53d38e5a93fdd0effa4c3059a">operator=</a> (const <a class="el" href="classnz_1_1data_1_1_tensor.html">Tensor</a> &amp;other)</td></tr>
<tr class="memdesc:acdb68bf53d38e5a93fdd0effa4c3059a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator for <a class="el" href="classnz_1_1data_1_1_tensor.html" title="A class for representing and manipulating multidimensional arrays (tensors) in GPU memory.">Tensor</a>.  <br /></td></tr>
<tr class="separator:acdb68bf53d38e5a93fdd0effa4c3059a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26b24cc132d14e054b3c25923516d781" id="r_a26b24cc132d14e054b3c25923516d781"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnz_1_1data_1_1_tensor.html">Tensor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a26b24cc132d14e054b3c25923516d781">operator=</a> (<a class="el" href="classnz_1_1data_1_1_tensor.html">Tensor</a> &amp;&amp;other) noexcept(false)</td></tr>
<tr class="memdesc:a26b24cc132d14e054b3c25923516d781"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator for <a class="el" href="classnz_1_1data_1_1_tensor.html" title="A class for representing and manipulating multidimensional arrays (tensors) in GPU memory.">Tensor</a>.  <br /></td></tr>
<tr class="separator:a26b24cc132d14e054b3c25923516d781"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98a8b254d2b6c8b4893d7a286452a9b0" id="r_a98a8b254d2b6c8b4893d7a286452a9b0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a98a8b254d2b6c8b4893d7a286452a9b0">~Tensor</a> () noexcept(false)</td></tr>
<tr class="memdesc:a98a8b254d2b6c8b4893d7a286452a9b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor for <a class="el" href="classnz_1_1data_1_1_tensor.html" title="A class for representing and manipulating multidimensional arrays (tensors) in GPU memory.">Tensor</a>.  <br /></td></tr>
<tr class="separator:a98a8b254d2b6c8b4893d7a286452a9b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Getters and Setters</div></td></tr>
<tr class="memitem:a7cbc6dd248b882c95840835d0deaae1c" id="r_a7cbc6dd248b882c95840835d0deaae1c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7cbc6dd248b882c95840835d0deaae1c">requiresGrad</a> () const noexcept</td></tr>
<tr class="memdesc:a7cbc6dd248b882c95840835d0deaae1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the tensor requires gradient computation.  <br /></td></tr>
<tr class="separator:a7cbc6dd248b882c95840835d0deaae1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aade7b0c42622279888d755f4f7989aac" id="r_aade7b0c42622279888d755f4f7989aac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnz_1_1data_1_1_dimension.html">shape_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aade7b0c42622279888d755f4f7989aac">shape</a> () const noexcept</td></tr>
<tr class="memdesc:aade7b0c42622279888d755f4f7989aac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the shape of the tensor.  <br /></td></tr>
<tr class="separator:aade7b0c42622279888d755f4f7989aac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31a3aa01fa3ccb56503994a99e39e177" id="r_a31a3aa01fa3ccb56503994a99e39e177"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a31a3aa01fa3ccb56503994a99e39e177">size</a> () const noexcept</td></tr>
<tr class="memdesc:a31a3aa01fa3ccb56503994a99e39e177"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the total number of elements in the tensor.  <br /></td></tr>
<tr class="separator:a31a3aa01fa3ccb56503994a99e39e177"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abddb47a6dc305d289a1e4f91d01a5082" id="r_abddb47a6dc305d289a1e4f91d01a5082"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abddb47a6dc305d289a1e4f91d01a5082">setRequiresGrad</a> (bool requires_grad)</td></tr>
<tr class="memdesc:abddb47a6dc305d289a1e4f91d01a5082"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets whether the tensor requires gradient computation.  <br /></td></tr>
<tr class="separator:abddb47a6dc305d289a1e4f91d01a5082"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38ba233ef49f34620297f96edd962c55" id="r_a38ba233ef49f34620297f96edd962c55"><td class="memItemLeft" align="right" valign="top">value_type *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a38ba233ef49f34620297f96edd962c55">data</a> () const noexcept</td></tr>
<tr class="memdesc:a38ba233ef49f34620297f96edd962c55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves a pointer to the tensor's data stored in GPU memory.  <br /></td></tr>
<tr class="separator:a38ba233ef49f34620297f96edd962c55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6107b98beb881d0209345185d5ad145" id="r_ad6107b98beb881d0209345185d5ad145"><td class="memItemLeft" align="right" valign="top">value_type *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad6107b98beb881d0209345185d5ad145">grad</a> () const</td></tr>
<tr class="memdesc:ad6107b98beb881d0209345185d5ad145"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves a pointer to the gradient data stored in GPU memory.  <br /></td></tr>
<tr class="separator:ad6107b98beb881d0209345185d5ad145"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf80894b8e06f260bb2695951e2f539e" id="r_adf80894b8e06f260bb2695951e2f539e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adf80894b8e06f260bb2695951e2f539e">dataInject</a> (value_type *<a class="el" href="#a38ba233ef49f34620297f96edd962c55">data</a>, bool <a class="el" href="#ad6107b98beb881d0209345185d5ad145">grad</a>=false) const</td></tr>
<tr class="memdesc:adf80894b8e06f260bb2695951e2f539e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Injects data or gradient data into the tensor.  <br /></td></tr>
<tr class="separator:adf80894b8e06f260bb2695951e2f539e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3cc31f5b541809d75556ebbfda8ae57" id="r_ae3cc31f5b541809d75556ebbfda8ae57"><td class="memTemplParams" colspan="2">template&lt;typename Iterator &gt; </td></tr>
<tr class="memitem:ae3cc31f5b541809d75556ebbfda8ae57"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae3cc31f5b541809d75556ebbfda8ae57">dataInject</a> (Iterator begin, Iterator end, const bool <a class="el" href="#ad6107b98beb881d0209345185d5ad145">grad</a>=false) const</td></tr>
<tr class="memdesc:ae3cc31f5b541809d75556ebbfda8ae57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Injects data or gradient data into the tensor using iterators.  <br /></td></tr>
<tr class="separator:ae3cc31f5b541809d75556ebbfda8ae57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c4217ad3ebcdb4a1bcf2fd38151d007" id="r_a2c4217ad3ebcdb4a1bcf2fd38151d007"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2c4217ad3ebcdb4a1bcf2fd38151d007">dataInject</a> (const std::initializer_list&lt; value_type &gt; &amp;<a class="el" href="#a38ba233ef49f34620297f96edd962c55">data</a>, bool <a class="el" href="#ad6107b98beb881d0209345185d5ad145">grad</a>=false) const</td></tr>
<tr class="memdesc:a2c4217ad3ebcdb4a1bcf2fd38151d007"><td class="mdescLeft">&#160;</td><td class="mdescRight">Injects data or gradient data into the tensor using a std::initializer_list.  <br /></td></tr>
<tr class="separator:a2c4217ad3ebcdb4a1bcf2fd38151d007"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Modifiers</div></td></tr>
<tr class="memitem:a6fed8efad540a7621dd6640b2f2466d0" id="r_a6fed8efad540a7621dd6640b2f2466d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6fed8efad540a7621dd6640b2f2466d0">zeroGrad</a> () const</td></tr>
<tr class="memdesc:a6fed8efad540a7621dd6640b2f2466d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the gradient data to zero.  <br /></td></tr>
<tr class="separator:a6fed8efad540a7621dd6640b2f2466d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a9f1d5fae2989181645e5f59f7666d8" id="r_a7a9f1d5fae2989181645e5f59f7666d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7a9f1d5fae2989181645e5f59f7666d8">randomize</a> (unsigned long long seed=0) const</td></tr>
<tr class="memdesc:a7a9f1d5fae2989181645e5f59f7666d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Randomizes the tensor's data with a uniform distribution.  <br /></td></tr>
<tr class="separator:a7a9f1d5fae2989181645e5f59f7666d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc4e6385b97cf7ceb8bb74748b73b681" id="r_afc4e6385b97cf7ceb8bb74748b73b681"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afc4e6385b97cf7ceb8bb74748b73b681">clear</a> () const</td></tr>
<tr class="memdesc:afc4e6385b97cf7ceb8bb74748b73b681"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the tensor's data by setting all elements to zero.  <br /></td></tr>
<tr class="separator:afc4e6385b97cf7ceb8bb74748b73b681"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad220de56b18c404611f07f2290cd7e9d" id="r_ad220de56b18c404611f07f2290cd7e9d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad220de56b18c404611f07f2290cd7e9d">fill</a> (value_type value, bool isGrad=false) const</td></tr>
<tr class="memdesc:ad220de56b18c404611f07f2290cd7e9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills the tensor's data with a specified value.  <br /></td></tr>
<tr class="separator:ad220de56b18c404611f07f2290cd7e9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a877f9f2704e39100142d81d289ddc3f2" id="r_a877f9f2704e39100142d81d289ddc3f2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a877f9f2704e39100142d81d289ddc3f2">reshape</a> (const <a class="el" href="classnz_1_1data_1_1_dimension.html">shape_type</a> &amp;<a class="el" href="#aade7b0c42622279888d755f4f7989aac">shape</a>)</td></tr>
<tr class="memdesc:a877f9f2704e39100142d81d289ddc3f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reshapes the tensor to the specified shape.  <br /></td></tr>
<tr class="separator:a877f9f2704e39100142d81d289ddc3f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45e6f84ae74111ced9a96bdf204b2294" id="r_a45e6f84ae74111ced9a96bdf204b2294"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a45e6f84ae74111ced9a96bdf204b2294">transpose</a> ()</td></tr>
<tr class="memdesc:a45e6f84ae74111ced9a96bdf204b2294"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transposes the tensor by swapping its dimensions and rearranging the data.  <br /></td></tr>
<tr class="separator:a45e6f84ae74111ced9a96bdf204b2294"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2cee8a54e65497113afd0c4f85dc02c" id="r_ae2cee8a54e65497113afd0c4f85dc02c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae2cee8a54e65497113afd0c4f85dc02c">setData</a> (const <a class="el" href="classnz_1_1data_1_1_dimension.html">shape_type</a> &amp;position, value_type value) const</td></tr>
<tr class="memdesc:ae2cee8a54e65497113afd0c4f85dc02c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a specific element of the tensor's data to a given value.  <br /></td></tr>
<tr class="separator:ae2cee8a54e65497113afd0c4f85dc02c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Math</div></td></tr>
<tr class="memitem:a36cd1679c45059de64deeca9152b0288" id="r_a36cd1679c45059de64deeca9152b0288"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnz_1_1data_1_1_tensor.html">Tensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a36cd1679c45059de64deeca9152b0288">operator+</a> (const <a class="el" href="classnz_1_1data_1_1_tensor.html">Tensor</a> &amp;other) const</td></tr>
<tr class="memdesc:a36cd1679c45059de64deeca9152b0288"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds two tensors element-wise and returns the result.  <br /></td></tr>
<tr class="separator:a36cd1679c45059de64deeca9152b0288"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25cc6634977413df0b67d6e7365448a2" id="r_a25cc6634977413df0b67d6e7365448a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnz_1_1data_1_1_tensor.html">Tensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a25cc6634977413df0b67d6e7365448a2">operator-</a> (const <a class="el" href="classnz_1_1data_1_1_tensor.html">Tensor</a> &amp;other) const</td></tr>
<tr class="memdesc:a25cc6634977413df0b67d6e7365448a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts one tensor from another element-wise and returns the result.  <br /></td></tr>
<tr class="separator:a25cc6634977413df0b67d6e7365448a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa22ac6f3de75ee92a4307320eda7e87" id="r_aaa22ac6f3de75ee92a4307320eda7e87"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnz_1_1data_1_1_tensor.html">Tensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaa22ac6f3de75ee92a4307320eda7e87">operator*</a> (const <a class="el" href="classnz_1_1data_1_1_tensor.html">Tensor</a> &amp;other) const</td></tr>
<tr class="memdesc:aaa22ac6f3de75ee92a4307320eda7e87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs matrix multiplication of two tensors (matrices) and returns the result.  <br /></td></tr>
<tr class="separator:aaa22ac6f3de75ee92a4307320eda7e87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad66d0c0f5d9ecb375e1006bc0aecf404" id="r_ad66d0c0f5d9ecb375e1006bc0aecf404"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnz_1_1data_1_1_tensor.html">Tensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad66d0c0f5d9ecb375e1006bc0aecf404">operator-</a> () const</td></tr>
<tr class="memdesc:ad66d0c0f5d9ecb375e1006bc0aecf404"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negates all elements of the tensor and returns the result.  <br /></td></tr>
<tr class="separator:ad66d0c0f5d9ecb375e1006bc0aecf404"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92c7313608326bb4123d6f08341a6d80" id="r_a92c7313608326bb4123d6f08341a6d80"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a92c7313608326bb4123d6f08341a6d80">operator==</a> (const <a class="el" href="classnz_1_1data_1_1_tensor.html">Tensor</a> &amp;other) const</td></tr>
<tr class="memdesc:a92c7313608326bb4123d6f08341a6d80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if two <a class="el" href="classnz_1_1data_1_1_tensor.html" title="A class for representing and manipulating multidimensional arrays (tensors) in GPU memory.">Tensor</a> objects are equal.  <br /></td></tr>
<tr class="separator:a92c7313608326bb4123d6f08341a6d80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae7b7714f78f4d366e66f1664d37d36a" id="r_aae7b7714f78f4d366e66f1664d37d36a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aae7b7714f78f4d366e66f1664d37d36a">operator!=</a> (const <a class="el" href="classnz_1_1data_1_1_tensor.html">Tensor</a> &amp;other) const</td></tr>
<tr class="memdesc:aae7b7714f78f4d366e66f1664d37d36a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if two <a class="el" href="classnz_1_1data_1_1_tensor.html" title="A class for representing and manipulating multidimensional arrays (tensors) in GPU memory.">Tensor</a> objects are not equal.  <br /></td></tr>
<tr class="separator:aae7b7714f78f4d366e66f1664d37d36a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a178a2240cd5d441be508490b2613fc55" id="r_a178a2240cd5d441be508490b2613fc55"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a178a2240cd5d441be508490b2613fc55">recip</a> () const</td></tr>
<tr class="memdesc:a178a2240cd5d441be508490b2613fc55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the reciprocal (1/x) of each element in the tensor and updates the tensor in-place.  <br /></td></tr>
<tr class="separator:a178a2240cd5d441be508490b2613fc55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a657091dfa6a490d873ab8e95d9bb9e" id="r_a4a657091dfa6a490d873ab8e95d9bb9e"><td class="memItemLeft" align="right" valign="top">value_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4a657091dfa6a490d873ab8e95d9bb9e">sum</a> () const</td></tr>
<tr class="memdesc:a4a657091dfa6a490d873ab8e95d9bb9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the sum of all elements in the <a class="el" href="classnz_1_1data_1_1_tensor.html" title="A class for representing and manipulating multidimensional arrays (tensors) in GPU memory.">Tensor</a>.  <br /></td></tr>
<tr class="separator:a4a657091dfa6a490d873ab8e95d9bb9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74aa515ba6b83aa1d05a7bb001b297b3" id="r_a74aa515ba6b83aa1d05a7bb001b297b3"><td class="memItemLeft" align="right" valign="top">value_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a74aa515ba6b83aa1d05a7bb001b297b3">sum</a> (size_type batch, size_type channel) const</td></tr>
<tr class="memdesc:a74aa515ba6b83aa1d05a7bb001b297b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the sum of elements in a specific batch and channel of a <a class="el" href="classnz_1_1data_1_1_tensor.html" title="A class for representing and manipulating multidimensional arrays (tensors) in GPU memory.">Tensor</a>.  <br /></td></tr>
<tr class="separator:a74aa515ba6b83aa1d05a7bb001b297b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1818a10415337403d43aad091a5a4c7" id="r_aa1818a10415337403d43aad091a5a4c7"><td class="memItemLeft" align="right" valign="top">value_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa1818a10415337403d43aad091a5a4c7">expSum</a> () const</td></tr>
<tr class="memdesc:aa1818a10415337403d43aad091a5a4c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the sum of the exponential values of all elements in the <a class="el" href="classnz_1_1data_1_1_tensor.html" title="A class for representing and manipulating multidimensional arrays (tensors) in GPU memory.">Tensor</a>.  <br /></td></tr>
<tr class="separator:aa1818a10415337403d43aad091a5a4c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4833838e9a704b6b8d29cbd53c6b3b1" id="r_ac4833838e9a704b6b8d29cbd53c6b3b1"><td class="memItemLeft" align="right" valign="top">value_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac4833838e9a704b6b8d29cbd53c6b3b1">expSum</a> (size_t batch, size_t channel) const</td></tr>
<tr class="memdesc:ac4833838e9a704b6b8d29cbd53c6b3b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the sum of exponential values of elements in a specific batch and channel of a <a class="el" href="classnz_1_1data_1_1_tensor.html" title="A class for representing and manipulating multidimensional arrays (tensors) in GPU memory.">Tensor</a>.  <br /></td></tr>
<tr class="separator:ac4833838e9a704b6b8d29cbd53c6b3b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aab89d371ff013c5c021a191bd7348e" id="r_a7aab89d371ff013c5c021a191bd7348e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7aab89d371ff013c5c021a191bd7348e">syncData</a> () const</td></tr>
<tr class="memdesc:a7aab89d371ff013c5c021a191bd7348e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronize the tensor data by waiting for all CUDA stream write operations to complete.  <br /></td></tr>
<tr class="separator:a7aab89d371ff013c5c021a191bd7348e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af28425ddc9bee1f75fd923a0de68c37b" id="r_af28425ddc9bee1f75fd923a0de68c37b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af28425ddc9bee1f75fd923a0de68c37b">syncGrad</a> () const</td></tr>
<tr class="memdesc:af28425ddc9bee1f75fd923a0de68c37b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronize the gradient data of the tensor if gradient computation is required.  <br /></td></tr>
<tr class="separator:af28425ddc9bee1f75fd923a0de68c37b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c150b841f02921eb7826a6e03d0267e" id="r_a0c150b841f02921eb7826a6e03d0267e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0c150b841f02921eb7826a6e03d0267e">sync</a> () const</td></tr>
<tr class="memdesc:a0c150b841f02921eb7826a6e03d0267e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronize both the tensor data and its gradient data.  <br /></td></tr>
<tr class="separator:a0c150b841f02921eb7826a6e03d0267e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Printer</div></td></tr>
<tr class="memitem:a4b02ed4d2afec1ce75931201af181e14" id="r_a4b02ed4d2afec1ce75931201af181e14"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4b02ed4d2afec1ce75931201af181e14">printGrad</a> (std::ostream &amp;os) const</td></tr>
<tr class="memdesc:a4b02ed4d2afec1ce75931201af181e14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the gradient values of the tensor to an output stream.  <br /></td></tr>
<tr class="separator:a4b02ed4d2afec1ce75931201af181e14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b2309d5428331f2e6f88037bb123c8f" id="r_a2b2309d5428331f2e6f88037bb123c8f"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2b2309d5428331f2e6f88037bb123c8f">print</a> (std::ostream &amp;os) const</td></tr>
<tr class="memdesc:a2b2309d5428331f2e6f88037bb123c8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the tensor data to an output stream.  <br /></td></tr>
<tr class="separator:a2b2309d5428331f2e6f88037bb123c8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:ab8eaa8e06861a868b7df1a9ee0616a1a" id="r_ab8eaa8e06861a868b7df1a9ee0616a1a"><td class="memItemLeft" align="right" valign="top">DL_API std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab8eaa8e06861a868b7df1a9ee0616a1a">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classnz_1_1data_1_1_tensor.html">Tensor</a> &amp;tensor)</td></tr>
<tr class="memdesc:ab8eaa8e06861a868b7df1a9ee0616a1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloads the <code>&lt;&lt;</code> operator to print the tensor's data to an output stream.  <br /></td></tr>
<tr class="separator:ab8eaa8e06861a868b7df1a9ee0616a1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ae147fdd4255f7d148aef41e3e436a9" id="r_a1ae147fdd4255f7d148aef41e3e436a9"><td class="memItemLeft" align="right" valign="top">DL_API std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1ae147fdd4255f7d148aef41e3e436a9">operator&gt;&gt;</a> (std::istream &amp;is, const <a class="el" href="classnz_1_1data_1_1_tensor.html">Tensor</a> &amp;tensor)</td></tr>
<tr class="memdesc:a1ae147fdd4255f7d148aef41e3e436a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloads the <code>&gt;&gt;</code> operator to read a tensor's data from an input stream.  <br /></td></tr>
<tr class="separator:a1ae147fdd4255f7d148aef41e3e436a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A class for representing and manipulating multidimensional arrays (tensors) in GPU memory. </p>
<p>The <code><a class="el" href="classnz_1_1data_1_1_tensor.html" title="A class for representing and manipulating multidimensional arrays (tensors) in GPU memory.">Tensor</a></code> class is designed for high-performance numerical computations in GPU-based environments. It provides a wide range of functionalities, including tensor creation, mathematical operations, memory management, and gradient computation for deep learning tasks.</p>
<h3><a class="anchor" id="autotoc_md81"></a>
Type Definitions:</h3>
<ul>
<li><code>size_type</code>: An alias for <code>unsigned long long</code>, used to represent the size of the tensor. Supports large tensors with up to 64-bit indices.</li>
<li><code>value_type</code>: An alias for <code>float</code>, representing the data type of the tensor elements. Suitable for most machine learning computations.</li>
<li><code>shape_type</code>: An alias for <code>std::vector&lt;int&gt;</code>, representing the shape of the tensor (e.g., <code>{2, 3}</code> for a 2x3 matrix).</li>
</ul>
<h3><a class="anchor" id="autotoc_md82"></a>
Key Features:</h3>
<ul>
<li><b>Memory Management</b>: Handles GPU memory allocation and deallocation using CUDA.</li>
<li><b>Flexible Initialization</b>: Supports initialization via shapes, data pointers, initializer lists, and iterators.</li>
<li><b>Mathematical Operations</b>: Includes overloaded operators (<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>) and activation functions (<code>ReLU</code>, <code>Sigmoid</code>, <code>Tanh</code>, etc.).</li>
<li><b>Gradient Support</b>: Tracks gradients for tensors that require gradient computation (<code>requires_grad</code>) to facilitate backpropagation in neural networks.</li>
<li><b>Shape Transformation</b>: Supports reshaping and transposing tensors.</li>
</ul>
<h3><a class="anchor" id="autotoc_md83"></a>
Usage Example:</h3>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacenz_1_1data.html">nz::data</a>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create a tensor that requires gradient with shape 2x3</span></div>
<div class="line"><a class="code hl_class" href="classnz_1_1data_1_1_tensor.html">Tensor</a> tensor({2, 3}, <span class="keyword">true</span>);</div>
<div class="line">tensor.<a class="code hl_function" href="#ad220de56b18c404611f07f2290cd7e9d">fill</a>(1.0f);     <span class="comment">// Fill the tensor with value 1.0</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Apply element-wise ReLU activation</span></div>
<div class="line"><a class="code hl_class" href="classnz_1_1data_1_1_tensor.html">Tensor</a> result = <a class="code hl_function" href="namespacenz_1_1data.html#a9bcee9a75db3d824b92ed17a59711428">ReLU</a>(tensor);</div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;ReLU activated tensor:&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">std::cout &lt;&lt; result &lt;&lt; std::endl;        <span class="comment">// Print the result of ReLU activation</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Perform matrix multiplication (2x3 * 3x2 = 2x2)</span></div>
<div class="line"><a class="code hl_class" href="classnz_1_1data_1_1_tensor.html">Tensor</a> tensor3({3, 2}, <span class="keyword">true</span>);</div>
<div class="line">tensor3.<a class="code hl_function" href="#adf80894b8e06f260bb2695951e2f539e">dataInject</a>({1.0f, 2.0f, 3.0f, 4.0f, 5.0f, 6.0f}); <span class="comment">// Fill tensor3 with values</span></div>
<div class="line"><a class="code hl_class" href="classnz_1_1data_1_1_tensor.html">Tensor</a> multiplied_result = tensor * tensor3;  <span class="comment">// Multiply tensor (2x3) by tensor3 (3x2)</span></div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Multiplication result (2x3 * 3x2 = 2x2):&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">std::cout &lt;&lt; multiplied_result &lt;&lt; std::endl;  <span class="comment">// Print the result of matrix multiplication</span></div>
<div class="ttc" id="aclassnz_1_1data_1_1_tensor_html"><div class="ttname"><a href="classnz_1_1data_1_1_tensor.html">nz::data::Tensor</a></div><div class="ttdoc">A class for representing and manipulating multidimensional arrays (tensors) in GPU memory.</div><div class="ttdef"><b>Definition</b> <a href="_tensor_8cuh_source.html#l00134">Tensor.cuh:134</a></div></div>
<div class="ttc" id="aclassnz_1_1data_1_1_tensor_html_ad220de56b18c404611f07f2290cd7e9d"><div class="ttname"><a href="#ad220de56b18c404611f07f2290cd7e9d">nz::data::Tensor::fill</a></div><div class="ttdeci">void fill(value_type value, bool isGrad=false) const</div><div class="ttdoc">Fills the tensor's data with a specified value.</div><div class="ttdef"><b>Definition</b> <a href="_tensor_8cu_source.html#l00300">Tensor.cu:300</a></div></div>
<div class="ttc" id="aclassnz_1_1data_1_1_tensor_html_adf80894b8e06f260bb2695951e2f539e"><div class="ttname"><a href="#adf80894b8e06f260bb2695951e2f539e">nz::data::Tensor::dataInject</a></div><div class="ttdeci">void dataInject(value_type *data, bool grad=false) const</div><div class="ttdoc">Injects data or gradient data into the tensor.</div><div class="ttdef"><b>Definition</b> <a href="_tensor_8cu_source.html#l00276">Tensor.cu:276</a></div></div>
<div class="ttc" id="anamespacenz_1_1data_html"><div class="ttname"><a href="namespacenz_1_1data.html">nz::data</a></div><div class="ttdoc">Contains data structures and utilities for tensor operations in machine learning workflows.</div><div class="ttdef"><b>Definition</b> <a href="_dimension_8cuh_source.html#l00009">Dimension.cuh:9</a></div></div>
<div class="ttc" id="anamespacenz_1_1data_html_a9bcee9a75db3d824b92ed17a59711428"><div class="ttname"><a href="namespacenz_1_1data.html#a9bcee9a75db3d824b92ed17a59711428">nz::data::ReLU</a></div><div class="ttdeci">T ReLU(T input)</div><div class="ttdoc">Apply the Rectified Linear Unit (ReLU) activation function element-wise to an input tensor.</div><div class="ttdef"><b>Definition</b> <a href="_tensor_operations_8cuh_source.html#l00047">TensorOperations.cuh:47</a></div></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd><ul>
<li>Ensure proper cleanup by calling the destructor or relying on RAII to avoid memory leaks.</li>
<li><a class="el" href="classnz_1_1data_1_1_tensor.html" title="A class for representing and manipulating multidimensional arrays (tensors) in GPU memory.">Tensor</a> size and shape must match during operations to prevent runtime errors.</li>
<li>Requires CUDA-compatible hardware and a properly configured environment.</li>
<li>Most of the methods in this class involve CUDA operations and may throw the <a class="el" href="classnz_1_1_cuda_exception.html" title="A final class that represents CUDA exceptions, inheriting from std::runtime_error.">nz::CudaException</a> in certain cases.</li>
</ul>
</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Mgepahmge(<a href="https://github.com/Mgepahmge">https://github.com/Mgepahmge</a>)</dd></dl>
<dl class="section date"><dt>Date</dt><dd>2024/11/29 </dd></dl>

<p class="definition">Definition at line <a class="el" href="_tensor_8cuh_source.html#l00134">134</a> of file <a class="el" href="_tensor_8cuh_source.html">Tensor.cuh</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ad0dda0efff93778cab46fd5aa708b983" name="ad0dda0efff93778cab46fd5aa708b983"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0dda0efff93778cab46fd5aa708b983">&#9670;&#160;</a></span>Tensor() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">nz::data::Tensor::Tensor </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default constructor for <a class="el" href="classnz_1_1data_1_1_tensor.html" title="A class for representing and manipulating multidimensional arrays (tensors) in GPU memory.">Tensor</a>. </p>
<p>Initializes an empty <a class="el" href="classnz_1_1data_1_1_tensor.html" title="A class for representing and manipulating multidimensional arrays (tensors) in GPU memory.">Tensor</a> with no data or shape. This constructor is primarily used as a placeholder or for initializing variables before assigning a valid tensor. </p>

<p class="definition">Definition at line <a class="el" href="_tensor_8cu_source.html#l00088">88</a> of file <a class="el" href="_tensor_8cu_source.html">Tensor.cu</a>.</p>

</div>
</div>
<a id="a6a3fc1e2d0b5154cdb4961679d0752af" name="a6a3fc1e2d0b5154cdb4961679d0752af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a3fc1e2d0b5154cdb4961679d0752af">&#9670;&#160;</a></span>Tensor() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">nz::data::Tensor::Tensor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnz_1_1data_1_1_dimension.html">shape_type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>shape</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>requires_grad</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor that initializes a <a class="el" href="classnz_1_1data_1_1_tensor.html" title="A class for representing and manipulating multidimensional arrays (tensors) in GPU memory.">Tensor</a> with the specified shape. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shape</td><td>A vector representing the dimensions of the tensor. </td></tr>
    <tr><td class="paramname">requires_grad</td><td>A boolean indicating whether the tensor requires gradient computation.</td></tr>
  </table>
  </dd>
</dl>
<p>This constructor allocates GPU memory for the tensor based on the specified shape. If <code>requires_grad</code> is set to true, additional memory is allocated for storing gradients. </p>

<p class="definition">Definition at line <a class="el" href="_tensor_8cu_source.html#l00092">92</a> of file <a class="el" href="_tensor_8cu_source.html">Tensor.cu</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classnz_1_1data_1_1_tensor_a6a3fc1e2d0b5154cdb4961679d0752af_cgraph.png" border="0" usemap="#aclassnz_1_1data_1_1_tensor_a6a3fc1e2d0b5154cdb4961679d0752af_cgraph" alt=""/></div>
<map name="aclassnz_1_1data_1_1_tensor_a6a3fc1e2d0b5154cdb4961679d0752af_cgraph" id="aclassnz_1_1data_1_1_tensor_a6a3fc1e2d0b5154cdb4961679d0752af_cgraph">
<area shape="rect" title="Constructor that initializes a Tensor with the specified shape." alt="" coords="5,47,168,73"/>
<area shape="rect" href="classnz_1_1cu_strm_1_1_stream_manager.html#ab4b2eb422e0e1ee44bdfdc0eb94457ce" title="Returns a reference to the singleton instance of the StreamManager." alt="" coords="216,5,401,48"/>
<area shape="poly" title=" " alt="" coords="168,45,200,40,200,46,169,50"/>
<area shape="rect" href="classnz_1_1cu_strm_1_1_stream_manager.html#a97f78a2d43f6e0508c82d4f3b629de96" title="Asynchronously allocates device memory for type&#45;specific data with stream&#45;ordered dependency tracking..." alt="" coords="216,72,401,115"/>
<area shape="poly" title=" " alt="" coords="169,70,200,74,200,80,168,75"/>
<area shape="rect" href="classnz_1_1cu_strm_1_1_stream_manager.html#a1de1cf3aadea137faf90a2f9b4b7abe2" title="Acquires CUDA stream from pool using round&#45;robin scheduling." alt="" coords="449,72,634,115"/>
<area shape="poly" title=" " alt="" coords="401,91,433,91,433,96,401,96"/>
</map>
</div>

</div>
</div>
<a id="ad65fa89fac9d72c92d34ace7e94610df" name="ad65fa89fac9d72c92d34ace7e94610df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad65fa89fac9d72c92d34ace7e94610df">&#9670;&#160;</a></span>Tensor() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">nz::data::Tensor::Tensor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnz_1_1data_1_1_dimension.html">shape_type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>shape</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">value_type *</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>requires_grad</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>host</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a <a class="el" href="classnz_1_1data_1_1_tensor.html" title="A class for representing and manipulating multidimensional arrays (tensors) in GPU memory.">Tensor</a> object with specified shape, data, gradient requirement, and data location. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shape</td><td>A reference to the shape of the tensor (host-to-device). The shape determines the size of the tensor. </td></tr>
    <tr><td class="paramname">data</td><td>A pointer to the initial data of the tensor. The data can be either on the host or device depending on the <code>host</code> parameter. </td></tr>
    <tr><td class="paramname">requires_grad</td><td>A boolean indicating whether the tensor requires gradient computation. </td></tr>
    <tr><td class="paramname">host</td><td>A boolean indicating whether the data pointed to by <code>data</code> is on the host or device. If true, data is on the host; otherwise, it is on the device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. This is a constructor.</dd></dl>
<p>This constructor initializes a <code><a class="el" href="classnz_1_1data_1_1_tensor.html" title="A class for representing and manipulating multidimensional arrays (tensors) in GPU memory.">Tensor</a></code> object. It first calculates the total size of the tensor based on the provided shape. Then, it allocates device memory for the tensor's data using <code>cudaMalloc</code>.</p>
<p>Depending on the value of the <code>host</code> parameter, it copies the data from either the host or another device memory location to the newly allocated device memory using <code>cudaMemcpy</code>.</p>
<p>If the <code>requires_grad</code> parameter is <code>true</code>, it also allocates device memory for the gradient data of the tensor. Otherwise, it sets the gradient pointer <code>_grad</code> to <code>nullptr</code>.</p>
<p>For memory management, the constructor allocates device memory for the tensor's data and gradient (if required). The responsibility of freeing this memory lies with the destructor of the <code><a class="el" href="classnz_1_1data_1_1_tensor.html" title="A class for representing and manipulating multidimensional arrays (tensors) in GPU memory.">Tensor</a></code> class.</p>
<p>In terms of exception handling, this constructor does not explicitly catch any CUDA errors. If a CUDA operation fails (e.g., <code>cudaMalloc</code> or <code>cudaMemcpy</code>), it will likely lead to undefined behavior in subsequent operations. It is the caller's responsibility to check for CUDA errors using <code>cudaGetLastError</code> or other appropriate methods.</p>
<p>This constructor is a fundamental part of the <code><a class="el" href="classnz_1_1data_1_1_tensor.html" title="A class for representing and manipulating multidimensional arrays (tensors) in GPU memory.">Tensor</a></code> class as it initializes the object's internal state.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>explicitly, but CUDA operations may fail and return an error code.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>Ensure that the <code>data</code> pointer is valid and points to enough data to fill the tensor according to the specified shape.</li>
<li>The CUDA runtime environment should be properly initialized before calling this constructor.</li>
<li>This constructor has a time complexity of O(1) for memory allocation and O(n) for data copying, where n is the total number of elements in the tensor (<code>_size</code>).</li>
</ul>
</dd></dl>
<div class="fragment"><div class="line">```cpp</div>
<div class="line"><a class="code hl_class" href="classnz_1_1data_1_1_dimension.html">shape_type</a> <a class="code hl_function" href="#aade7b0c42622279888d755f4f7989aac">shape</a> = {2, 3};</div>
<div class="line">value_type <a class="code hl_function" href="#a38ba233ef49f34620297f96edd962c55">data</a>[] = {1.0f, 2.0f, 3.0f, 4.0f, 5.0f, 6.0f};</div>
<div class="line"><a class="code hl_function" href="#ad0dda0efff93778cab46fd5aa708b983">Tensor</a> tensor(<a class="code hl_function" href="#aade7b0c42622279888d755f4f7989aac">shape</a>, <a class="code hl_function" href="#a38ba233ef49f34620297f96edd962c55">data</a>, <span class="keyword">true</span>, <span class="keyword">true</span>);</div>
<div class="line">```</div>
<div class="ttc" id="aclassnz_1_1data_1_1_dimension_html"><div class="ttname"><a href="classnz_1_1data_1_1_dimension.html">nz::data::Dimension</a></div><div class="ttdoc">Represents a multi - dimensional shape, typically used in deep learning for tensor dimensions.</div><div class="ttdef"><b>Definition</b> <a href="_dimension_8cuh_source.html#l00057">Dimension.cuh:57</a></div></div>
<div class="ttc" id="aclassnz_1_1data_1_1_tensor_html_a38ba233ef49f34620297f96edd962c55"><div class="ttname"><a href="#a38ba233ef49f34620297f96edd962c55">nz::data::Tensor::data</a></div><div class="ttdeci">value_type * data() const noexcept</div><div class="ttdoc">Retrieves a pointer to the tensor's data stored in GPU memory.</div><div class="ttdef"><b>Definition</b> <a href="_tensor_8cu_source.html#l00419">Tensor.cu:419</a></div></div>
<div class="ttc" id="aclassnz_1_1data_1_1_tensor_html_aade7b0c42622279888d755f4f7989aac"><div class="ttname"><a href="#aade7b0c42622279888d755f4f7989aac">nz::data::Tensor::shape</a></div><div class="ttdeci">shape_type shape() const noexcept</div><div class="ttdoc">Retrieves the shape of the tensor.</div><div class="ttdef"><b>Definition</b> <a href="_tensor_8cu_source.html#l00219">Tensor.cu:219</a></div></div>
<div class="ttc" id="aclassnz_1_1data_1_1_tensor_html_ad0dda0efff93778cab46fd5aa708b983"><div class="ttname"><a href="#ad0dda0efff93778cab46fd5aa708b983">nz::data::Tensor::Tensor</a></div><div class="ttdeci">Tensor()</div><div class="ttdoc">Default constructor for Tensor.</div><div class="ttdef"><b>Definition</b> <a href="_tensor_8cu_source.html#l00088">Tensor.cu:88</a></div></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="_tensor_8cu_source.html#l00104">104</a> of file <a class="el" href="_tensor_8cu_source.html">Tensor.cu</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classnz_1_1data_1_1_tensor_ad65fa89fac9d72c92d34ace7e94610df_cgraph.png" border="0" usemap="#aclassnz_1_1data_1_1_tensor_ad65fa89fac9d72c92d34ace7e94610df_cgraph" alt=""/></div>
<map name="aclassnz_1_1data_1_1_tensor_ad65fa89fac9d72c92d34ace7e94610df_cgraph" id="aclassnz_1_1data_1_1_tensor_ad65fa89fac9d72c92d34ace7e94610df_cgraph">
<area shape="rect" title="Constructs a Tensor object with specified shape, data, gradient requirement, and data location." alt="" coords="5,97,168,124"/>
<area shape="rect" href="classnz_1_1data_1_1_tensor.html#a38ba233ef49f34620297f96edd962c55" title="Retrieves a pointer to the tensor&#39;s data stored in GPU memory." alt="" coords="234,5,382,32"/>
<area shape="poly" title=" " alt="" coords="109,95,157,68,215,42,234,35,236,40,217,46,159,73,112,99"/>
<area shape="rect" href="classnz_1_1cu_strm_1_1_stream_manager.html#ab4b2eb422e0e1ee44bdfdc0eb94457ce" title="Returns a reference to the singleton instance of the StreamManager." alt="" coords="216,56,401,99"/>
<area shape="poly" title=" " alt="" coords="168,96,200,91,200,96,169,101"/>
<area shape="rect" href="classnz_1_1cu_strm_1_1_stream_manager.html#a97f78a2d43f6e0508c82d4f3b629de96" title="Asynchronously allocates device memory for type&#45;specific data with stream&#45;ordered dependency tracking..." alt="" coords="216,123,401,165"/>
<area shape="poly" title=" " alt="" coords="169,120,200,125,200,130,168,126"/>
<area shape="rect" href="classnz_1_1cu_strm_1_1_stream_manager.html#afa38d5c6db0e6b48c8f74ce8ad0df2bc" title="Asynchronously copies data between CUDA device and host memory based on the specified memory copy kin..." alt="" coords="216,189,401,232"/>
<area shape="poly" title=" " alt="" coords="113,122,217,175,231,181,228,186,215,180,111,127"/>
<area shape="rect" href="classnz_1_1cu_strm_1_1_stream_manager.html#a1de1cf3aadea137faf90a2f9b4b7abe2" title="Acquires CUDA stream from pool using round&#45;robin scheduling." alt="" coords="449,123,634,165"/>
<area shape="poly" title=" " alt="" coords="401,141,433,141,433,147,401,147"/>
<area shape="poly" title=" " alt="" coords="384,186,449,168,450,173,386,191"/>
<area shape="rect" href="classnz_1_1cu_strm_1_1_stream_manager.html#adb1078a67c6e38932d7d58c2adb05ec0" title="Synchronizes CUDA stream execution until data writes complete." alt="" coords="449,189,634,232"/>
<area shape="poly" title=" " alt="" coords="401,208,433,208,433,213,401,213"/>
</map>
</div>

</div>
</div>
<a id="a18937864a9eb48eb91a5d82ebf9c010e" name="a18937864a9eb48eb91a5d82ebf9c010e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18937864a9eb48eb91a5d82ebf9c010e">&#9670;&#160;</a></span>Tensor() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">nz::data::Tensor::Tensor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnz_1_1data_1_1_dimension.html">shape_type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>shape</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::initializer_list&lt; value_type &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>requires_grad</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a <a class="el" href="classnz_1_1data_1_1_tensor.html" title="A class for representing and manipulating multidimensional arrays (tensors) in GPU memory.">Tensor</a> object with a specified shape, initializer list data, and gradient requirement. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shape</td><td>A reference to the shape of the tensor (host-to-device). The shape determines the dimensions and total size of the tensor. </td></tr>
    <tr><td class="paramname">data</td><td>A std::initializer_list containing the initial data for the tensor (host-to-device). </td></tr>
    <tr><td class="paramname">requires_grad</td><td>A boolean indicating whether the tensor requires gradient computation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. This is a constructor.</dd></dl>
<p>This constructor initializes a <a class="el" href="classnz_1_1data_1_1_tensor.html" title="A class for representing and manipulating multidimensional arrays (tensors) in GPU memory.">Tensor</a> object. First, it calculates the total size of the tensor based on the provided shape. It then checks if the size of the std::initializer_list is sufficient to fill the tensor. If not, it throws a std::invalid_argument exception.</p>
<p>For memory management, it allocates device memory for the tensor's data using cudaMalloc. If the tensor requires gradient computation, it also allocates device memory for the gradient data; otherwise, it sets the gradient pointer to nullptr.</p>
<p>A temporary host buffer is created to hold the data from the std::initializer_list. The data is copied from the initializer list to the host buffer and then transferred from the host buffer to the device memory using cudaMemcpy. After the transfer, the temporary host buffer is deleted to prevent memory leaks.</p>
<p>Regarding exception handling, it throws a std::invalid_argument if the initializer list size is insufficient. Any CUDA errors during memory allocation or data transfer are not explicitly caught here, and it's the caller's responsibility to check for CUDA errors.</p>
<p>This constructor is an important part of the <a class="el" href="classnz_1_1data_1_1_tensor.html" title="A class for representing and manipulating multidimensional arrays (tensors) in GPU memory.">Tensor</a> class as it provides a convenient way to initialize a tensor with an initializer list.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>If the size of the std::initializer_list is less than the size of the tensor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>Ensure that the std::initializer_list contains enough elements to fill the tensor according to the specified shape.</li>
<li>The CUDA runtime environment should be properly initialized before calling this constructor.</li>
<li>The time complexity of this constructor is O(n), where n is the total number of elements in the tensor, due to the loop that copies data from the initializer list to the host buffer.</li>
</ul>
</dd></dl>
<div class="fragment"><div class="line">```cpp</div>
<div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classnz_1_1data_1_1_dimension.html">shape_type</a> <a class="code hl_function" href="#aade7b0c42622279888d755f4f7989aac">shape</a> = {2, 3};</div>
<div class="line"><span class="keywordflow">try</span> {</div>
<div class="line">    <a class="code hl_class" href="classnz_1_1data_1_1_tensor.html">Tensor</a> tensor(<a class="code hl_function" href="#aade7b0c42622279888d755f4f7989aac">shape</a>, {1.0f, 2.0f, 3.0f, 4.0f, 5.0f, 6.0f}, <span class="keyword">true</span>);</div>
<div class="line">} <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::invalid_argument&amp; e) {</div>
<div class="line">    std::cerr &lt;&lt; e.what() &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="line">```</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="_tensor_8cu_source.html#l00123">123</a> of file <a class="el" href="_tensor_8cu_source.html">Tensor.cu</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classnz_1_1data_1_1_tensor_a18937864a9eb48eb91a5d82ebf9c010e_cgraph.png" border="0" usemap="#aclassnz_1_1data_1_1_tensor_a18937864a9eb48eb91a5d82ebf9c010e_cgraph" alt=""/></div>
<map name="aclassnz_1_1data_1_1_tensor_a18937864a9eb48eb91a5d82ebf9c010e_cgraph" id="aclassnz_1_1data_1_1_tensor_a18937864a9eb48eb91a5d82ebf9c010e_cgraph">
<area shape="rect" title="Constructs a Tensor object with a specified shape, initializer list data, and gradient requirement." alt="" coords="5,97,168,124"/>
<area shape="rect" href="classnz_1_1data_1_1_tensor.html#a38ba233ef49f34620297f96edd962c55" title="Retrieves a pointer to the tensor&#39;s data stored in GPU memory." alt="" coords="234,5,382,32"/>
<area shape="poly" title=" " alt="" coords="109,95,157,68,215,42,234,35,236,40,217,46,159,73,112,99"/>
<area shape="rect" href="classnz_1_1cu_strm_1_1_stream_manager.html#ab4b2eb422e0e1ee44bdfdc0eb94457ce" title="Returns a reference to the singleton instance of the StreamManager." alt="" coords="216,56,401,99"/>
<area shape="poly" title=" " alt="" coords="168,96,200,91,200,96,169,101"/>
<area shape="rect" href="classnz_1_1cu_strm_1_1_stream_manager.html#a97f78a2d43f6e0508c82d4f3b629de96" title="Asynchronously allocates device memory for type&#45;specific data with stream&#45;ordered dependency tracking..." alt="" coords="216,123,401,165"/>
<area shape="poly" title=" " alt="" coords="169,120,200,125,200,130,168,126"/>
<area shape="rect" href="classnz_1_1cu_strm_1_1_stream_manager.html#afa38d5c6db0e6b48c8f74ce8ad0df2bc" title="Asynchronously copies data between CUDA device and host memory based on the specified memory copy kin..." alt="" coords="216,189,401,232"/>
<area shape="poly" title=" " alt="" coords="113,122,217,175,231,181,228,186,215,180,111,127"/>
<area shape="rect" href="classnz_1_1cu_strm_1_1_stream_manager.html#a1de1cf3aadea137faf90a2f9b4b7abe2" title="Acquires CUDA stream from pool using round&#45;robin scheduling." alt="" coords="449,123,634,165"/>
<area shape="poly" title=" " alt="" coords="401,141,433,141,433,147,401,147"/>
<area shape="poly" title=" " alt="" coords="384,186,449,168,450,173,386,191"/>
<area shape="rect" href="classnz_1_1cu_strm_1_1_stream_manager.html#adb1078a67c6e38932d7d58c2adb05ec0" title="Synchronizes CUDA stream execution until data writes complete." alt="" coords="449,189,634,232"/>
<area shape="poly" title=" " alt="" coords="401,208,433,208,433,213,401,213"/>
</map>
</div>

</div>
</div>
<a id="a6184f0270420ac054f7bd372bbed1406" name="a6184f0270420ac054f7bd372bbed1406"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6184f0270420ac054f7bd372bbed1406">&#9670;&#160;</a></span>Tensor() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">nz::data::Tensor::Tensor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnz_1_1data_1_1_tensor.html">Tensor</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy constructor for <a class="el" href="classnz_1_1data_1_1_tensor.html" title="A class for representing and manipulating multidimensional arrays (tensors) in GPU memory.">Tensor</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The <a class="el" href="classnz_1_1data_1_1_tensor.html" title="A class for representing and manipulating multidimensional arrays (tensors) in GPU memory.">Tensor</a> object to copy from.</td></tr>
  </table>
  </dd>
</dl>
<p>Performs a deep copy of the tensor, including its shape, data, and gradient (if applicable). </p>

<p class="definition">Definition at line <a class="el" href="_tensor_8cu_source.html#l00146">146</a> of file <a class="el" href="_tensor_8cu_source.html">Tensor.cu</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classnz_1_1data_1_1_tensor_a6184f0270420ac054f7bd372bbed1406_cgraph.png" border="0" usemap="#aclassnz_1_1data_1_1_tensor_a6184f0270420ac054f7bd372bbed1406_cgraph" alt=""/></div>
<map name="aclassnz_1_1data_1_1_tensor_a6184f0270420ac054f7bd372bbed1406_cgraph" id="aclassnz_1_1data_1_1_tensor_a6184f0270420ac054f7bd372bbed1406_cgraph">
<area shape="rect" title="Copy constructor for Tensor." alt="" coords="5,80,168,107"/>
<area shape="rect" href="classnz_1_1cu_strm_1_1_stream_manager.html#ab4b2eb422e0e1ee44bdfdc0eb94457ce" title="Returns a reference to the singleton instance of the StreamManager." alt="" coords="216,5,401,48"/>
<area shape="poly" title=" " alt="" coords="133,77,220,50,221,56,135,82"/>
<area shape="rect" href="classnz_1_1cu_strm_1_1_stream_manager.html#a97f78a2d43f6e0508c82d4f3b629de96" title="Asynchronously allocates device memory for type&#45;specific data with stream&#45;ordered dependency tracking..." alt="" coords="216,72,401,115"/>
<area shape="poly" title=" " alt="" coords="168,91,200,91,200,96,168,96"/>
<area shape="rect" href="classnz_1_1cu_strm_1_1_stream_manager.html#afa38d5c6db0e6b48c8f74ce8ad0df2bc" title="Asynchronously copies data between CUDA device and host memory based on the specified memory copy kin..." alt="" coords="216,139,401,181"/>
<area shape="poly" title=" " alt="" coords="135,105,221,131,220,136,133,110"/>
<area shape="rect" href="classnz_1_1cu_strm_1_1_stream_manager.html#a1de1cf3aadea137faf90a2f9b4b7abe2" title="Acquires CUDA stream from pool using round&#45;robin scheduling." alt="" coords="449,72,634,115"/>
<area shape="poly" title=" " alt="" coords="401,91,433,91,433,96,401,96"/>
<area shape="poly" title=" " alt="" coords="384,136,449,117,450,122,386,141"/>
<area shape="rect" href="classnz_1_1cu_strm_1_1_stream_manager.html#adb1078a67c6e38932d7d58c2adb05ec0" title="Synchronizes CUDA stream execution until data writes complete." alt="" coords="449,139,634,181"/>
<area shape="poly" title=" " alt="" coords="401,157,433,157,433,163,401,163"/>
</map>
</div>

</div>
</div>
<a id="adb57f91ae907875d78d804de85dbbc73" name="adb57f91ae907875d78d804de85dbbc73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb57f91ae907875d78d804de85dbbc73">&#9670;&#160;</a></span>Tensor() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">nz::data::Tensor::Tensor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnz_1_1data_1_1_tensor.html">Tensor</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move constructor for <a class="el" href="classnz_1_1data_1_1_tensor.html" title="A class for representing and manipulating multidimensional arrays (tensors) in GPU memory.">Tensor</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The <a class="el" href="classnz_1_1data_1_1_tensor.html" title="A class for representing and manipulating multidimensional arrays (tensors) in GPU memory.">Tensor</a> object to move from.</td></tr>
  </table>
  </dd>
</dl>
<p>Moves the tensor data and ownership of the GPU memory to the new object. </p>

<p class="definition">Definition at line <a class="el" href="_tensor_8cu_source.html#l00161">161</a> of file <a class="el" href="_tensor_8cu_source.html">Tensor.cu</a>.</p>

</div>
</div>
<a id="a98a8b254d2b6c8b4893d7a286452a9b0" name="a98a8b254d2b6c8b4893d7a286452a9b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98a8b254d2b6c8b4893d7a286452a9b0">&#9670;&#160;</a></span>~Tensor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">nz::data::Tensor::~Tensor </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destructor for <a class="el" href="classnz_1_1data_1_1_tensor.html" title="A class for representing and manipulating multidimensional arrays (tensors) in GPU memory.">Tensor</a>. </p>
<p>Releases all GPU memory allocated for the tensor's data and gradient. Ensures that no memory leaks occur during the lifetime of the <a class="el" href="classnz_1_1data_1_1_tensor.html" title="A class for representing and manipulating multidimensional arrays (tensors) in GPU memory.">Tensor</a> object. </p>

<p class="definition">Definition at line <a class="el" href="_tensor_8cu_source.html#l00210">210</a> of file <a class="el" href="_tensor_8cu_source.html">Tensor.cu</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classnz_1_1data_1_1_tensor_a98a8b254d2b6c8b4893d7a286452a9b0_cgraph.png" border="0" usemap="#aclassnz_1_1data_1_1_tensor_a98a8b254d2b6c8b4893d7a286452a9b0_cgraph" alt=""/></div>
<map name="aclassnz_1_1data_1_1_tensor_a98a8b254d2b6c8b4893d7a286452a9b0_cgraph" id="aclassnz_1_1data_1_1_tensor_a98a8b254d2b6c8b4893d7a286452a9b0_cgraph">
<area shape="rect" title="Destructor for Tensor." alt="" coords="5,39,129,81"/>
<area shape="rect" href="classnz_1_1cu_strm_1_1_stream_manager.html#a785cf34395067f425e032d9bd5e1fa20" title="Frees the CUDA device memory pointed to by the given pointer." alt="" coords="177,5,362,48"/>
<area shape="poly" title=" " alt="" coords="129,47,161,42,162,47,130,52"/>
<area shape="rect" href="classnz_1_1cu_strm_1_1_stream_manager.html#ab4b2eb422e0e1ee44bdfdc0eb94457ce" title="Returns a reference to the singleton instance of the StreamManager." alt="" coords="177,72,362,115"/>
<area shape="poly" title=" " alt="" coords="130,68,162,73,161,78,129,73"/>
<area shape="rect" href="classnz_1_1cu_strm_1_1_stream_manager.html#abe439fa00c0bd369c0b2345b095ed5af" title="Synchronizes host thread with completion events for a specific data object." alt="" coords="410,5,595,48"/>
<area shape="poly" title=" " alt="" coords="362,24,394,24,394,29,362,29"/>
</map>
</div>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="afc4e6385b97cf7ceb8bb74748b73b681" name="afc4e6385b97cf7ceb8bb74748b73b681"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc4e6385b97cf7ceb8bb74748b73b681">&#9670;&#160;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nz::data::Tensor::clear </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears the tensor's data by setting all elements to zero. </p>
<p>This function resets the tensor's data to zero by filling the memory allocated for the tensor's data with zero values. It uses the <code>cudaMemset</code> function to set all the values in the tensor's GPU memory to zero. This is commonly used to clear or reset the tensor before using it for new computations.</p>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>This function does not deallocate the memory; it only sets the values in the tensor's data to zero.</li>
<li>The tensor's data memory is assumed to be allocated before calling this function. This is automatically managed when the tensor is created, so no additional memory allocation is needed.</li>
</ul>
</dd></dl>
<div class="fragment"><div class="line">```cpp</div>
<div class="line"><a class="code hl_class" href="classnz_1_1data_1_1_tensor.html">Tensor</a> tensor({2, 3});  <span class="comment">// Create a tensor with shape 2x3</span></div>
<div class="line">tensor.<a class="code hl_function" href="#afc4e6385b97cf7ceb8bb74748b73b681">clear</a>();         <span class="comment">// Clear the tensor&#39;s data by setting all elements to zero</span></div>
<div class="line">```</div>
<div class="ttc" id="aclassnz_1_1data_1_1_tensor_html_afc4e6385b97cf7ceb8bb74748b73b681"><div class="ttname"><a href="#afc4e6385b97cf7ceb8bb74748b73b681">nz::data::Tensor::clear</a></div><div class="ttdeci">void clear() const</div><div class="ttdoc">Clears the tensor's data by setting all elements to zero.</div><div class="ttdef"><b>Definition</b> <a href="_tensor_8cu_source.html#l00296">Tensor.cu:296</a></div></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="_tensor_8cu_source.html#l00296">296</a> of file <a class="el" href="_tensor_8cu_source.html">Tensor.cu</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classnz_1_1data_1_1_tensor_afc4e6385b97cf7ceb8bb74748b73b681_cgraph.png" border="0" usemap="#aclassnz_1_1data_1_1_tensor_afc4e6385b97cf7ceb8bb74748b73b681_cgraph" alt=""/></div>
<map name="aclassnz_1_1data_1_1_tensor_afc4e6385b97cf7ceb8bb74748b73b681_cgraph" id="aclassnz_1_1data_1_1_tensor_afc4e6385b97cf7ceb8bb74748b73b681_cgraph">
<area shape="rect" title="Clears the tensor&#39;s data by setting all elements to zero." alt="" coords="5,47,157,73"/>
<area shape="rect" href="classnz_1_1cu_strm_1_1_stream_manager.html#ab4b2eb422e0e1ee44bdfdc0eb94457ce" title="Returns a reference to the singleton instance of the StreamManager." alt="" coords="205,5,390,48"/>
<area shape="poly" title=" " alt="" coords="157,46,188,41,189,46,157,51"/>
<area shape="rect" href="classnz_1_1cu_strm_1_1_stream_manager.html#a71ad766cb2869d3dd6a3931966e81706" title="Asynchronously sets a block of CUDA device memory to a specified value." alt="" coords="205,72,390,115"/>
<area shape="poly" title=" " alt="" coords="157,69,189,74,188,79,157,74"/>
<area shape="rect" href="classnz_1_1cu_strm_1_1_stream_manager.html#a1de1cf3aadea137faf90a2f9b4b7abe2" title="Acquires CUDA stream from pool using round&#45;robin scheduling." alt="" coords="438,39,623,81"/>
<area shape="poly" title=" " alt="" coords="390,77,422,73,423,78,391,83"/>
<area shape="rect" href="classnz_1_1cu_strm_1_1_stream_manager.html#adb1078a67c6e38932d7d58c2adb05ec0" title="Synchronizes CUDA stream execution until data writes complete." alt="" coords="438,105,623,148"/>
<area shape="poly" title=" " alt="" coords="391,104,423,109,422,114,390,109"/>
</map>
</div>

</div>
</div>
<a id="a38ba233ef49f34620297f96edd962c55" name="a38ba233ef49f34620297f96edd962c55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38ba233ef49f34620297f96edd962c55">&#9670;&#160;</a></span>data()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Tensor::value_type * nz::data::Tensor::data </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves a pointer to the tensor's data stored in GPU memory. </p>
<dl class="section return"><dt>Returns</dt><dd>A <code>value_type*</code> (pointer to float) pointing to the tensor's data in GPU memory.</dd></dl>
<p>This function provides direct access to the raw data of the tensor stored in GPU memory. It is useful for low-level operations or when interfacing with other libraries that require access to the tensor's memory.</p>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>The returned pointer points to GPU memory, so it cannot be directly dereferenced in CPU code.</li>
<li>Ensure that CUDA synchronization is handled properly before using this pointer in GPU operations.</li>
</ul>
</dd></dl>
<div class="fragment"><div class="line">```cpp</div>
<div class="line"><a class="code hl_class" href="classnz_1_1data_1_1_tensor.html">Tensor</a> tensor({2, 3});</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">float</span>* gpu_data = tensor.<a class="code hl_function" href="#a38ba233ef49f34620297f96edd962c55">data</a>(); <span class="comment">// Access raw data</span></div>
<div class="line"><span class="comment">// Use gpu_data in CUDA kernels or other GPU-based operations</span></div>
<div class="line">```</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="_tensor_8cu_source.html#l00419">419</a> of file <a class="el" href="_tensor_8cu_source.html">Tensor.cu</a>.</p>

</div>
</div>
<a id="a2c4217ad3ebcdb4a1bcf2fd38151d007" name="a2c4217ad3ebcdb4a1bcf2fd38151d007"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c4217ad3ebcdb4a1bcf2fd38151d007">&#9670;&#160;</a></span>dataInject() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nz::data::Tensor::dataInject </td>
          <td>(</td>
          <td class="paramtype">const std::initializer_list&lt; value_type &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>grad</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Injects data or gradient data into the tensor using a std::initializer_list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>A std::initializer_list containing the data to be injected (host-to-device). </td></tr>
    <tr><td class="paramname">grad</td><td>A boolean indicating whether to inject gradient data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function serves as a wrapper that calls another <code>dataInject</code> function, passing the begin and end iterators of the provided <code>std::initializer_list</code>. In terms of memory management, it relies on the underlying <code>dataInject</code> function to handle memory operations for the actual data injection. Regarding exception handling, it simply propagates any exceptions thrown by the underlying <code>dataInject</code> function without additional handling. This function is closely related to the <code><a class="el" href="classnz_1_1data_1_1_tensor.html" title="A class for representing and manipulating multidimensional arrays (tensors) in GPU memory.">Tensor</a></code> class and the other <code>dataInject</code> functions as it leverages the existing data injection logic.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>If the length of the input array is less than the size of the tensor. </td></tr>
    <tr><td class="paramname"><a class="el" href="classnz_1_1_cuda_exception.html" title="A final class that represents CUDA exceptions, inheriting from std::runtime_error.">nz::CudaException</a></td><td>If the CUDA memory copy fails or if the tensor does not require gradients when trying to inject gradient data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>The <code>std::initializer_list</code> should contain enough elements to fill the tensor.</li>
<li>This function has a time complexity of O(1) for the wrapper itself, but the overall complexity depends on the underlying <code>dataInject</code> function which is O(n) where n is the size of the tensor.</li>
</ul>
</dd></dl>
<div class="fragment"><div class="line">```cpp</div>
<div class="line"><a class="code hl_class" href="classnz_1_1data_1_1_tensor.html">Tensor</a> tensor({1,3});</div>
<div class="line"><span class="keywordflow">try</span> {</div>
<div class="line">    tensor.dataInject({1.0f, 2.0f, 3.0f}, <span class="keyword">false</span>);</div>
<div class="line">} <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::runtime_error&amp; e) {</div>
<div class="line">    std::cerr &lt;&lt; e.what() &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="line">```</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="_tensor_8cu_source.html#l00235">235</a> of file <a class="el" href="_tensor_8cu_source.html">Tensor.cu</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classnz_1_1data_1_1_tensor_a2c4217ad3ebcdb4a1bcf2fd38151d007_cgraph.png" border="0" usemap="#aclassnz_1_1data_1_1_tensor_a2c4217ad3ebcdb4a1bcf2fd38151d007_cgraph" alt=""/></div>
<map name="aclassnz_1_1data_1_1_tensor_a2c4217ad3ebcdb4a1bcf2fd38151d007_cgraph" id="aclassnz_1_1data_1_1_tensor_a2c4217ad3ebcdb4a1bcf2fd38151d007_cgraph">
<area shape="rect" title="Injects data or gradient data into the tensor using a std::initializer_list." alt="" coords="5,56,186,83"/>
<area shape="rect" href="classnz_1_1data_1_1_tensor.html#a38ba233ef49f34620297f96edd962c55" title="Retrieves a pointer to the tensor&#39;s data stored in GPU memory." alt="" coords="480,5,629,32"/>
<area shape="poly" title=" " alt="" coords="186,54,233,48,465,24,466,29,234,53,187,59"/>
<area shape="rect" href="classnz_1_1data_1_1_tensor.html#adf80894b8e06f260bb2695951e2f539e" title="Injects data or gradient data into the tensor." alt="" coords="234,107,414,133"/>
<area shape="poly" title=" " alt="" coords="160,81,246,100,245,105,159,86"/>
<area shape="rect" href="classnz_1_1data_1_1_tensor.html#ad6107b98beb881d0209345185d5ad145" title="Retrieves a pointer to the gradient data stored in GPU memory." alt="" coords="480,56,629,83"/>
<area shape="poly" title=" " alt="" coords="186,67,465,67,465,72,186,72"/>
<area shape="poly" title=" " alt="" coords="345,104,397,73,461,42,480,35,482,40,463,46,399,78,348,109"/>
<area shape="poly" title=" " alt="" coords="388,103,475,84,477,89,389,109"/>
<area shape="rect" href="classnz_1_1cu_strm_1_1_stream_manager.html#ab4b2eb422e0e1ee44bdfdc0eb94457ce" title="Returns a reference to the singleton instance of the StreamManager." alt="" coords="462,107,647,149"/>
<area shape="poly" title=" " alt="" coords="414,120,447,122,446,127,414,126"/>
<area shape="rect" href="classnz_1_1cu_strm_1_1_stream_manager.html#afa38d5c6db0e6b48c8f74ce8ad0df2bc" title="Asynchronously copies data between CUDA device and host memory based on the specified memory copy kin..." alt="" coords="462,173,647,216"/>
<area shape="poly" title=" " alt="" coords="368,131,473,166,471,171,367,136"/>
<area shape="rect" href="classnz_1_1cu_strm_1_1_stream_manager.html#a1de1cf3aadea137faf90a2f9b4b7abe2" title="Acquires CUDA stream from pool using round&#45;robin scheduling." alt="" coords="695,140,881,183"/>
<area shape="poly" title=" " alt="" coords="647,179,679,174,680,179,648,184"/>
<area shape="rect" href="classnz_1_1cu_strm_1_1_stream_manager.html#adb1078a67c6e38932d7d58c2adb05ec0" title="Synchronizes CUDA stream execution until data writes complete." alt="" coords="695,207,881,249"/>
<area shape="poly" title=" " alt="" coords="648,205,680,210,679,215,647,211"/>
</map>
</div>

</div>
</div>
<a id="ae3cc31f5b541809d75556ebbfda8ae57" name="ae3cc31f5b541809d75556ebbfda8ae57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3cc31f5b541809d75556ebbfda8ae57">&#9670;&#160;</a></span>dataInject() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nz::data::Tensor::dataInject </td>
          <td>(</td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>begin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>end</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>grad</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Injects data or gradient data into the tensor using iterators. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>An iterator pointing to the beginning of the input data range (host-to-device). </td></tr>
    <tr><td class="paramname">end</td><td>An iterator pointing to the end of the input data range (host-to-device). </td></tr>
    <tr><td class="paramname">grad</td><td>A boolean indicating whether to inject gradient data. Defaults to false.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function injects data or gradient data into the tensor using the provided iterator range. First, it checks if the length of the input range (determined by <code>std::distance(begin, end)</code>) is at least as large as the size of the tensor (<code>_size</code>). If not, it throws a <code>std::runtime_error</code>.</p>
<p>For memory management, it allocates a temporary host array <code>host_data</code> of size <code>_size</code> to store the data from the iterator range. The data is then copied from the iterator range to this temporary array. After that, it calls the <code>dataInject</code> function with the temporary array and the <code>grad</code> flag.</p>
<p>In case of an exception during the call to the <code>dataInject</code> function, the temporary array is deleted to prevent memory leaks. Finally, the temporary array is deleted after the call to <code>dataInject</code> returns successfully.</p>
<p>The exception handling mechanism catches any <code><a class="el" href="classnz_1_1_cuda_exception.html" title="A final class that represents CUDA exceptions, inheriting from std::runtime_error.">nz::CudaException</a></code> or <code>std::runtime_error</code> thrown by the <code>dataInject</code> function and re - throws it after cleaning up the temporary memory.</p>
<p>This function is closely related to the <code><a class="el" href="classnz_1_1data_1_1_tensor.html" title="A class for representing and manipulating multidimensional arrays (tensors) in GPU memory.">Tensor</a></code> class and the other <code>dataInject</code> function as it uses the other <code>dataInject</code> function to perform the actual data injection.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>If the length of the input array is less than the size of the tensor. </td></tr>
    <tr><td class="paramname"><a class="el" href="classnz_1_1_cuda_exception.html" title="A final class that represents CUDA exceptions, inheriting from std::runtime_error.">nz::CudaException</a></td><td>If the CUDA memory copy fails or if the tensor does not require gradients when trying to inject gradient data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>The iterators <code>begin</code> and <code>end</code> should be valid and form a proper range.</li>
<li>The input data should be convertible to the <code>value_type</code> of the tensor.</li>
<li>The time complexity of this function is O(n), where n is the size of the tensor (<code>_size</code>), due to the loop that copies data from the iterator range to the temporary array.</li>
</ul>
</dd></dl>
<div class="fragment"><div class="line">```cpp</div>
<div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div>
<div class="line"><a class="code hl_class" href="classnz_1_1data_1_1_tensor.html">Tensor</a> tensor({1,3});</div>
<div class="line">std::vector&lt;float&gt; <a class="code hl_function" href="#a38ba233ef49f34620297f96edd962c55">data</a> = {1.0f, 2.0f, 3.0f};</div>
<div class="line"><span class="keywordflow">try</span> {</div>
<div class="line">    tensor.dataInject(<a class="code hl_function" href="#a38ba233ef49f34620297f96edd962c55">data</a>.begin(), <a class="code hl_function" href="#a38ba233ef49f34620297f96edd962c55">data</a>.end(), <span class="keyword">false</span>);</div>
<div class="line">} <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::runtime_error&amp; e) {</div>
<div class="line">    std::cerr &lt;&lt; e.what() &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="line">```</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="_tensor_8cuh_source.html#l00481">481</a> of file <a class="el" href="_tensor_8cuh_source.html">Tensor.cuh</a>.</p>

</div>
</div>
<a id="adf80894b8e06f260bb2695951e2f539e" name="adf80894b8e06f260bb2695951e2f539e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf80894b8e06f260bb2695951e2f539e">&#9670;&#160;</a></span>dataInject() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nz::data::Tensor::dataInject </td>
          <td>(</td>
          <td class="paramtype">value_type *</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>grad</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Injects data or gradient data into the tensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>A pointer to the data to be injected (host-to-device). </td></tr>
    <tr><td class="paramname">grad</td><td>A boolean indicating whether to inject gradient data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function is responsible for injecting data or gradient data into the tensor. For memory management, it uses <code>cudaMemcpy</code> to copy data from the host to the device. If the <code>grad</code> parameter is <code>true</code>, it tries to copy data to the gradient buffer (<code>_grad</code>). If the tensor does not require gradients (<code>_requires_grad</code> is <code>false</code>), it throws an exception. If the <code>grad</code> parameter is <code>false</code>, it copies data to the main data buffer (<code>_data</code>).</p>
<p>The exception handling mechanism is in place to catch any CUDA memory copy errors. If the <code>cudaMemcpy</code> operation fails, it throws a <code><a class="el" href="classnz_1_1_cuda_exception.html" title="A final class that represents CUDA exceptions, inheriting from std::runtime_error.">nz::CudaException</a></code> with an appropriate error message.</p>
<p>This function is closely related to the <code><a class="el" href="classnz_1_1data_1_1_tensor.html" title="A class for representing and manipulating multidimensional arrays (tensors) in GPU memory.">Tensor</a></code> class as it modifies the internal data of the tensor.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classnz_1_1_cuda_exception.html" title="A final class that represents CUDA exceptions, inheriting from std::runtime_error.">nz::CudaException</a></td><td>If the CUDA memory copy fails or if the tensor does not require gradients when trying to inject gradient data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>The input data pointer <code>data</code> should point to a valid memory location with enough data to fill the tensor.</li>
<li>Ensure that the CUDA environment is properly initialized before calling this function.</li>
</ul>
</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function is not safe. If the length of the input array pointed to by <code>data</code> is less than the size of the tensor, it will lead to undefined behavior and potentially cause unknown issues in the program.</dd></dl>
<div class="fragment"><div class="line">```cpp</div>
<div class="line"><a class="code hl_class" href="classnz_1_1data_1_1_tensor.html">Tensor</a> tensor({1, 3});</div>
<div class="line"><span class="keywordtype">float</span> <a class="code hl_function" href="#a38ba233ef49f34620297f96edd962c55">data</a>[] = {1.0, 2.0, 3.0};</div>
<div class="line"><span class="keywordflow">try</span> {</div>
<div class="line">    tensor.dataInject(<a class="code hl_function" href="#a38ba233ef49f34620297f96edd962c55">data</a>, <span class="keyword">false</span>);</div>
<div class="line">} <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::runtime_error&amp; e) {</div>
<div class="line">    std::cerr &lt;&lt; e.what() &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="line">```</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="_tensor_8cu_source.html#l00276">276</a> of file <a class="el" href="_tensor_8cu_source.html">Tensor.cu</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classnz_1_1data_1_1_tensor_adf80894b8e06f260bb2695951e2f539e_cgraph.png" border="0" usemap="#aclassnz_1_1data_1_1_tensor_adf80894b8e06f260bb2695951e2f539e_cgraph" alt=""/></div>
<map name="aclassnz_1_1data_1_1_tensor_adf80894b8e06f260bb2695951e2f539e_cgraph" id="aclassnz_1_1data_1_1_tensor_adf80894b8e06f260bb2695951e2f539e_cgraph">
<area shape="rect" title="Injects data or gradient data into the tensor." alt="" coords="5,85,186,112"/>
<area shape="rect" href="classnz_1_1data_1_1_tensor.html#a38ba233ef49f34620297f96edd962c55" title="Retrieves a pointer to the tensor&#39;s data stored in GPU memory." alt="" coords="252,5,400,32"/>
<area shape="poly" title=" " alt="" coords="128,82,233,41,256,34,257,39,235,47,130,87"/>
<area shape="rect" href="classnz_1_1data_1_1_tensor.html#ad6107b98beb881d0209345185d5ad145" title="Retrieves a pointer to the gradient data stored in GPU memory." alt="" coords="252,56,400,83"/>
<area shape="poly" title=" " alt="" coords="185,85,236,78,237,83,186,90"/>
<area shape="rect" href="classnz_1_1cu_strm_1_1_stream_manager.html#ab4b2eb422e0e1ee44bdfdc0eb94457ce" title="Returns a reference to the singleton instance of the StreamManager." alt="" coords="234,107,419,149"/>
<area shape="poly" title=" " alt="" coords="186,107,219,112,218,117,185,113"/>
<area shape="rect" href="classnz_1_1cu_strm_1_1_stream_manager.html#afa38d5c6db0e6b48c8f74ce8ad0df2bc" title="Asynchronously copies data between CUDA device and host memory based on the specified memory copy kin..." alt="" coords="234,173,419,216"/>
<area shape="poly" title=" " alt="" coords="126,110,235,159,250,165,248,170,233,164,124,115"/>
<area shape="rect" href="classnz_1_1cu_strm_1_1_stream_manager.html#a1de1cf3aadea137faf90a2f9b4b7abe2" title="Acquires CUDA stream from pool using round&#45;robin scheduling." alt="" coords="467,140,652,183"/>
<area shape="poly" title=" " alt="" coords="419,179,451,174,452,179,420,184"/>
<area shape="rect" href="classnz_1_1cu_strm_1_1_stream_manager.html#adb1078a67c6e38932d7d58c2adb05ec0" title="Synchronizes CUDA stream execution until data writes complete." alt="" coords="467,207,652,249"/>
<area shape="poly" title=" " alt="" coords="420,205,452,210,451,215,419,211"/>
</map>
</div>

</div>
</div>
<a id="aa1818a10415337403d43aad091a5a4c7" name="aa1818a10415337403d43aad091a5a4c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1818a10415337403d43aad091a5a4c7">&#9670;&#160;</a></span>expSum() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Tensor::value_type nz::data::Tensor::expSum </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the sum of the exponential values of all elements in the <a class="el" href="classnz_1_1data_1_1_tensor.html" title="A class for representing and manipulating multidimensional arrays (tensors) in GPU memory.">Tensor</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>The sum of the exponential values of all elements in the <a class="el" href="classnz_1_1data_1_1_tensor.html" title="A class for representing and manipulating multidimensional arrays (tensors) in GPU memory.">Tensor</a> as a value of type <code>Tensor::value_type</code>.</dd></dl>
<p>This function calculates the sum of the exponential values of all elements in the <a class="el" href="classnz_1_1data_1_1_tensor.html" title="A class for representing and manipulating multidimensional arrays (tensors) in GPU memory.">Tensor</a>. It first configures the CUDA block and grid dimensions. Then, it allocates device memory for intermediate results and host memory to hold the copied results from the device. The <code><a class="el" href="namespacenz_1_1krnl.html#a51a5ff3c8cc2c3051fddf32de294b467" title="Kernel function to compute the summation of exponentials of each element in the input array.">krnl::SummationExp</a></code> CUDA kernel is launched to compute the partial sums of the exponential values on the device. After the kernel execution, the partial sums are transferred from the device to the host using <code>cudaMemcpy</code>. Finally, the partial sums on the host are added together to obtain the total sum, and the allocated host and device memory are freed.</p>
<p>Memory management:</p><ul>
<li>Host memory is allocated for <code>hData</code> using <code>new[]</code> and freed using <code>delete[]</code>.</li>
<li>Device memory is allocated for <code>dData</code> using <code>cudaMalloc</code> and freed using <code>cudaFree</code>.</li>
</ul>
<p>Exception handling:</p><ul>
<li>The <code>CHECK</code> macro is used to handle CUDA API errors. If a CUDA API call fails, the <code>CHECK</code> macro will throw an exception, and the function will terminate.</li>
</ul>
<p>Relationship with other components:</p><ul>
<li>This function depends on the <code><a class="el" href="namespacenz_1_1krnl.html#a51a5ff3c8cc2c3051fddf32de294b467" title="Kernel function to compute the summation of exponentials of each element in the input array.">krnl::SummationExp</a></code> CUDA kernel to perform the partial sums of exponential values on the device.</li>
<li>It also depends on the <code>CHECK</code> macro to handle CUDA API errors.</li>
</ul>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">[Exception</td><td>type thrown by CHECK macro] If there are CUDA API errors during memory allocation, kernel execution, or memory copying.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>The time complexity of this function is approximately O(n), where n is the number of elements in the <a class="el" href="classnz_1_1data_1_1_tensor.html" title="A class for representing and manipulating multidimensional arrays (tensors) in GPU memory.">Tensor</a> (<code>_size</code>). The CUDA kernel parallelizes the partial sum calculation of exponential values, and the final sum on the host is a linear operation over the number of grid blocks.</li>
<li>Ensure that the CUDA device is properly initialized before calling this function.</li>
</ul>
</dd></dl>
<div class="fragment"><div class="line">```cpp</div>
<div class="line"><a class="code hl_class" href="classnz_1_1data_1_1_tensor.html">nz::data::Tensor</a> tensor({2, 3}, <span class="keyword">true</span>);</div>
<div class="line"><span class="comment">// Assume tensor is filled with some values</span></div>
<div class="line">nz::data::Tensor::value_type exp_sum_result = tensor.<a class="code hl_function" href="#aa1818a10415337403d43aad091a5a4c7">expSum</a>();</div>
<div class="line">```</div>
<div class="ttc" id="aclassnz_1_1data_1_1_tensor_html_aa1818a10415337403d43aad091a5a4c7"><div class="ttname"><a href="#aa1818a10415337403d43aad091a5a4c7">nz::data::Tensor::expSum</a></div><div class="ttdeci">value_type expSum() const</div><div class="ttdoc">Compute the sum of the exponential values of all elements in the Tensor.</div><div class="ttdef"><b>Definition</b> <a href="_tensor_8cu_source.html#l00562">Tensor.cu:562</a></div></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="_tensor_8cu_source.html#l00562">562</a> of file <a class="el" href="_tensor_8cu_source.html">Tensor.cu</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classnz_1_1data_1_1_tensor_aa1818a10415337403d43aad091a5a4c7_cgraph.png" border="0" usemap="#aclassnz_1_1data_1_1_tensor_aa1818a10415337403d43aad091a5a4c7_cgraph" alt=""/></div>
<map name="aclassnz_1_1data_1_1_tensor_aa1818a10415337403d43aad091a5a4c7_cgraph" id="aclassnz_1_1data_1_1_tensor_aa1818a10415337403d43aad091a5a4c7_cgraph">
<area shape="rect" title="Compute the sum of the exponential values of all elements in the Tensor." alt="" coords="5,139,177,165"/>
<area shape="rect" href="classnz_1_1cu_strm_1_1_stream_manager.html#a785cf34395067f425e032d9bd5e1fa20" title="Frees the CUDA device memory pointed to by the given pointer." alt="" coords="225,12,410,55"/>
<area shape="poly" title=" " alt="" coords="115,136,223,76,256,60,258,64,226,81,118,140"/>
<area shape="rect" href="classnz_1_1cu_strm_1_1_stream_manager.html#ab4b2eb422e0e1ee44bdfdc0eb94457ce" title="Returns a reference to the singleton instance of the StreamManager." alt="" coords="458,72,643,115"/>
<area shape="poly" title=" " alt="" coords="159,135,224,124,442,99,443,105,225,129,160,141"/>
<area shape="rect" href="classnz_1_1cu_strm_1_1_stream_manager.html#a97f78a2d43f6e0508c82d4f3b629de96" title="Asynchronously allocates device memory for type&#45;specific data with stream&#45;ordered dependency tracking..." alt="" coords="225,252,410,295"/>
<area shape="poly" title=" " alt="" coords="118,164,226,223,262,242,259,247,223,228,116,168"/>
<area shape="rect" href="classnz_1_1cu_strm_1_1_stream_manager.html#afa38d5c6db0e6b48c8f74ce8ad0df2bc" title="Asynchronously copies data between CUDA device and host memory based on the specified memory copy kin..." alt="" coords="458,205,643,248"/>
<area shape="poly" title=" " alt="" coords="163,163,225,175,443,209,442,214,224,180,162,169"/>
<area shape="rect" href="namespacenz_1_1krnl.html#a51a5ff3c8cc2c3051fddf32de294b467" title="Kernel function to compute the summation of exponentials of each element in the input array." alt="" coords="237,139,398,165"/>
<area shape="poly" title=" " alt="" coords="177,149,221,149,221,155,177,155"/>
<area shape="rect" href="classnz_1_1cu_strm_1_1_stream_manager.html#abe439fa00c0bd369c0b2345b095ed5af" title="Synchronizes host thread with completion events for a specific data object." alt="" coords="458,5,643,48"/>
<area shape="poly" title=" " alt="" coords="410,28,442,27,443,32,411,33"/>
<area shape="rect" href="classnz_1_1cu_strm_1_1_stream_manager.html#a1de1cf3aadea137faf90a2f9b4b7abe2" title="Acquires CUDA stream from pool using round&#45;robin scheduling." alt="" coords="691,205,877,248"/>
<area shape="poly" title=" " alt="" coords="410,272,522,268,643,257,687,249,688,255,644,263,522,274,410,277"/>
<area shape="poly" title=" " alt="" coords="644,224,676,224,676,229,644,229"/>
<area shape="rect" href="classnz_1_1cu_strm_1_1_stream_manager.html#adb1078a67c6e38932d7d58c2adb05ec0" title="Synchronizes CUDA stream execution until data writes complete." alt="" coords="691,139,877,181"/>
<area shape="poly" title=" " alt="" coords="627,202,691,184,693,189,628,207"/>
<area shape="poly" title=" " alt="" coords="373,136,448,116,449,122,374,141"/>
<area shape="rect" href="classnz_1_1cu_strm_1_1_stream_manager.html#a46ce59b45de432842454aadf00b93791" title="Asynchronously submits a CUDA kernel with stream&#45;ordered dependency management." alt="" coords="458,139,643,181"/>
<area shape="poly" title=" " alt="" coords="398,152,443,154,443,159,398,157"/>
<area shape="poly" title=" " alt="" coords="628,179,693,198,691,203,627,184"/>
<area shape="poly" title=" " alt="" coords="644,157,676,157,676,163,644,163"/>
</map>
</div>

</div>
</div>
<a id="ac4833838e9a704b6b8d29cbd53c6b3b1" name="ac4833838e9a704b6b8d29cbd53c6b3b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4833838e9a704b6b8d29cbd53c6b3b1">&#9670;&#160;</a></span>expSum() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Tensor::value_type nz::data::Tensor::expSum </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>batch</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>channel</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the sum of exponential values of elements in a specific batch and channel of a <a class="el" href="classnz_1_1data_1_1_tensor.html" title="A class for representing and manipulating multidimensional arrays (tensors) in GPU memory.">Tensor</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">batch</td><td>The batch index. Memory flow: host - to - device (used for index calculation on the host side). </td></tr>
    <tr><td class="paramname">channel</td><td>The channel index. Memory flow: host - to - device (used for index calculation on the host side).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sum of exponential values of elements in the specified batch and channel of the <a class="el" href="classnz_1_1data_1_1_tensor.html" title="A class for representing and manipulating multidimensional arrays (tensors) in GPU memory.">Tensor</a>.</dd></dl>
<p>This function calculates the sum of the exponential values of elements within a particular batch and channel of a <a class="el" href="classnz_1_1data_1_1_tensor.html" title="A class for representing and manipulating multidimensional arrays (tensors) in GPU memory.">Tensor</a>. First, it validates the provided <code>batch</code> and <code>channel</code> indices. If they are out of the valid range of the <a class="el" href="classnz_1_1data_1_1_tensor.html" title="A class for representing and manipulating multidimensional arrays (tensors) in GPU memory.">Tensor</a>'s shape, it throws a <code>std::invalid_argument</code> exception.</p>
<p>After validation, it computes the size of the region to be processed based on the <a class="el" href="classnz_1_1data_1_1_tensor.html" title="A class for representing and manipulating multidimensional arrays (tensors) in GPU memory.">Tensor</a>'s shape. It then allocates device memory for intermediate results (<code>dData</code>) and host memory (<code>hData</code>) to receive the computed values from the device. The offset in the <a class="el" href="classnz_1_1data_1_1_tensor.html" title="A class for representing and manipulating multidimensional arrays (tensors) in GPU memory.">Tensor</a>'s data is determined according to the <code>batch</code> and <code>channel</code> indices.</p>
<p>The <code><a class="el" href="namespacenz_1_1krnl.html#a51a5ff3c8cc2c3051fddf32de294b467" title="Kernel function to compute the summation of exponentials of each element in the input array.">krnl::SummationExp</a></code> kernel is launched to compute the exponential of each element and perform partial summation on the device. The intermediate results are then copied from the device to the host. Finally, the function sums up all the intermediate results on the host, frees the allocated host and device memory, and returns the final sum.</p>
<p><b>Memory Management Strategy</b>:</p><ul>
<li>On the host side, an array <code>hData</code> of size <code>grid.x</code> is dynamically allocated using <code>new[]</code> and later freed using <code>delete[]</code>.</li>
<li>On the device side, memory for <code>dData</code> is allocated using <code><a class="el" href="classnz_1_1cu_strm_1_1_stream_manager.html" title="Centralized CUDA stream and resource management system with automatic dependency tracking.">cuStrm::StreamManager</a>&lt;value_type&gt;::Instance().malloc</code> and freed using <code><a class="el" href="classnz_1_1cu_strm_1_1_stream_manager.html" title="Centralized CUDA stream and resource management system with automatic dependency tracking.">cuStrm::StreamManager</a>&lt;value_type&gt;::Instance().free</code>.</li>
</ul>
<p><b>Exception Handling Mechanism</b>:</p><ul>
<li>Throws a <code>std::invalid_argument</code> exception if the provided <code>batch</code> or <code>channel</code> indices are out of the valid range of the <a class="el" href="classnz_1_1data_1_1_tensor.html" title="A class for representing and manipulating multidimensional arrays (tensors) in GPU memory.">Tensor</a>'s shape.</li>
<li>The CUDA memory allocation, copying, and kernel launch operations may return error codes indicating failures. It is assumed that the calling code or the CUDA runtime will handle these errors appropriately.</li>
</ul>
<p><b>Relationship with Other Components</b>:</p><ul>
<li>Depends on the <code>_shape</code> member of the <code><a class="el" href="classnz_1_1data_1_1_tensor.html" title="A class for representing and manipulating multidimensional arrays (tensors) in GPU memory.">Tensor</a></code> class to get the shape information and strides.</li>
<li>Uses the <code><a class="el" href="namespacenz_1_1krnl.html#a51a5ff3c8cc2c3051fddf32de294b467" title="Kernel function to compute the summation of exponentials of each element in the input array.">krnl::SummationExp</a></code> kernel to perform the exponential calculation and partial summation on the device.</li>
<li>Relies on <code><a class="el" href="classnz_1_1cu_strm_1_1_stream_manager.html" title="Centralized CUDA stream and resource management system with automatic dependency tracking.">cuStrm::StreamManager</a>&lt;value_type&gt;::Instance()</code> for CUDA memory management (malloc, memcpy, free) operations.</li>
</ul>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>If the provided <code>batch</code> or <code>channel</code> indices are out of the valid range of the <a class="el" href="classnz_1_1data_1_1_tensor.html" title="A class for representing and manipulating multidimensional arrays (tensors) in GPU memory.">Tensor</a>'s shape.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>Ensure that the provided <code>batch</code> and <code>channel</code> indices are within the valid range of the <a class="el" href="classnz_1_1data_1_1_tensor.html" title="A class for representing and manipulating multidimensional arrays (tensors) in GPU memory.">Tensor</a>'s shape to avoid exceptions.</li>
<li>Be aware of potential CUDA errors during memory allocation, copying, and kernel launch operations and handle them appropriately in the calling code.</li>
</ul>
</dd></dl>
<div class="fragment"><div class="line">```cpp</div>
<div class="line"><a class="code hl_class" href="classnz_1_1data_1_1_tensor.html">Tensor</a> tensor; <span class="comment">// Assume Tensor is properly initialized</span></div>
<div class="line"><span class="keywordtype">size_t</span> batch = 0;</div>
<div class="line"><span class="keywordtype">size_t</span> channel = 1;</div>
<div class="line">Tensor::value_type expSumResult = tensor.<a class="code hl_function" href="#aa1818a10415337403d43aad091a5a4c7">expSum</a>(batch, channel);</div>
<div class="line">```</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="_tensor_8cu_source.html#l00580">580</a> of file <a class="el" href="_tensor_8cu_source.html">Tensor.cu</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classnz_1_1data_1_1_tensor_ac4833838e9a704b6b8d29cbd53c6b3b1_cgraph.png" border="0" usemap="#aclassnz_1_1data_1_1_tensor_ac4833838e9a704b6b8d29cbd53c6b3b1_cgraph" alt=""/></div>
<map name="aclassnz_1_1data_1_1_tensor_ac4833838e9a704b6b8d29cbd53c6b3b1_cgraph" id="aclassnz_1_1data_1_1_tensor_ac4833838e9a704b6b8d29cbd53c6b3b1_cgraph">
<area shape="rect" title="Computes the sum of exponential values of elements in a specific batch and channel of a Tensor." alt="" coords="5,164,177,191"/>
<area shape="rect" href="classnz_1_1cu_strm_1_1_stream_manager.html#a785cf34395067f425e032d9bd5e1fa20" title="Frees the CUDA device memory pointed to by the given pointer." alt="" coords="225,5,410,48"/>
<area shape="poly" title=" " alt="" coords="103,162,152,112,186,83,223,58,232,53,235,57,226,62,190,87,156,116,106,165"/>
<area shape="rect" href="classnz_1_1cu_strm_1_1_stream_manager.html#ab4b2eb422e0e1ee44bdfdc0eb94457ce" title="Returns a reference to the singleton instance of the StreamManager." alt="" coords="458,131,643,173"/>
<area shape="poly" title=" " alt="" coords="177,170,442,155,442,161,177,175"/>
<area shape="rect" href="classnz_1_1cu_strm_1_1_stream_manager.html#a97f78a2d43f6e0508c82d4f3b629de96" title="Asynchronously allocates device memory for type&#45;specific data with stream&#45;ordered dependency tracking..." alt="" coords="225,72,410,115"/>
<area shape="poly" title=" " alt="" coords="128,161,242,118,244,123,130,166"/>
<area shape="rect" href="classnz_1_1cu_strm_1_1_stream_manager.html#afa38d5c6db0e6b48c8f74ce8ad0df2bc" title="Asynchronously copies data between CUDA device and host memory based on the specified memory copy kin..." alt="" coords="458,264,643,307"/>
<area shape="poly" title=" " alt="" coords="106,189,155,235,189,258,226,276,279,290,335,297,391,299,442,297,442,302,391,304,335,303,278,295,224,281,186,263,152,239,103,193"/>
<area shape="rect" href="classnz_1_1data_1_1_tensor.html#a31a3aa01fa3ccb56503994a99e39e177" title="Retrieves the total number of elements in the tensor." alt="" coords="244,240,391,267"/>
<area shape="poly" title=" " alt="" coords="127,189,226,225,249,233,248,238,224,231,125,194"/>
<area shape="rect" href="namespacenz_1_1krnl.html#a51a5ff3c8cc2c3051fddf32de294b467" title="Kernel function to compute the summation of exponentials of each element in the input array." alt="" coords="237,189,398,216"/>
<area shape="poly" title=" " alt="" coords="177,184,221,189,221,195,177,190"/>
<area shape="rect" href="classnz_1_1cu_strm_1_1_stream_manager.html#abe439fa00c0bd369c0b2345b095ed5af" title="Synchronizes host thread with completion events for a specific data object." alt="" coords="458,5,643,48"/>
<area shape="poly" title=" " alt="" coords="410,24,442,24,442,29,410,29"/>
<area shape="rect" href="classnz_1_1cu_strm_1_1_stream_manager.html#a1de1cf3aadea137faf90a2f9b4b7abe2" title="Acquires CUDA stream from pool using round&#45;robin scheduling." alt="" coords="691,197,877,240"/>
<area shape="poly" title=" " alt="" coords="410,85,464,85,524,90,585,99,644,116,675,130,703,147,751,185,748,189,700,152,672,135,642,121,584,105,523,95,464,91,410,90"/>
<area shape="poly" title=" " alt="" coords="627,261,691,242,693,247,628,266"/>
<area shape="rect" href="classnz_1_1cu_strm_1_1_stream_manager.html#adb1078a67c6e38932d7d58c2adb05ec0" title="Synchronizes CUDA stream execution until data writes complete." alt="" coords="691,264,877,307"/>
<area shape="poly" title=" " alt="" coords="644,283,676,283,676,288,644,288"/>
<area shape="poly" title=" " alt="" coords="382,186,442,173,443,178,383,191"/>
<area shape="rect" href="classnz_1_1cu_strm_1_1_stream_manager.html#a46ce59b45de432842454aadf00b93791" title="Asynchronously submits a CUDA kernel with stream&#45;ordered dependency management." alt="" coords="458,197,643,240"/>
<area shape="poly" title=" " alt="" coords="398,206,443,209,442,214,398,211"/>
<area shape="poly" title=" " alt="" coords="644,216,676,216,676,221,644,221"/>
<area shape="poly" title=" " alt="" coords="628,238,693,257,691,262,627,243"/>
</map>
</div>

</div>
</div>
<a id="ad220de56b18c404611f07f2290cd7e9d" name="ad220de56b18c404611f07f2290cd7e9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad220de56b18c404611f07f2290cd7e9d">&#9670;&#160;</a></span>fill()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nz::data::Tensor::fill </td>
          <td>(</td>
          <td class="paramtype">value_type</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>isGrad</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fills the tensor's data with a specified value. </p>
<p>This function sets all elements in the tensor's data to the specified value. It uses the <code>cudaMemset</code> function to fill the GPU memory allocated for the tensor with the provided value. This is commonly used to initialize a tensor with a constant value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value to which all elements of the tensor will be set. This value is copied to every element in the tensor's data. </td></tr>
    <tr><td class="paramname">isGrad</td><td>A boolean flag indicating whether to fill the gradients or the data. If true, gradients are filled; otherwise, data is filled (host-to-device).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>This function does not deallocate the memory; it only sets the values in the tensor's data to the specified value.</li>
<li>The tensor's data memory is assumed to be allocated before calling this function. This is automatically managed when the tensor is created, so no additional memory allocation is needed.</li>
</ul>
</dd></dl>
<div class="fragment"><div class="line">```cpp</div>
<div class="line"><a class="code hl_class" href="classnz_1_1data_1_1_tensor.html">Tensor</a> tensor({2, 3});  <span class="comment">// Create a tensor with shape 2x3</span></div>
<div class="line">tensor.<a class="code hl_function" href="#ad220de56b18c404611f07f2290cd7e9d">fill</a>(5.0f);      <span class="comment">// Fill the tensor&#39;s data with the value 5.0f</span></div>
<div class="line">```</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="_tensor_8cu_source.html#l00300">300</a> of file <a class="el" href="_tensor_8cu_source.html">Tensor.cu</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classnz_1_1data_1_1_tensor_ad220de56b18c404611f07f2290cd7e9d_cgraph.png" border="0" usemap="#aclassnz_1_1data_1_1_tensor_ad220de56b18c404611f07f2290cd7e9d_cgraph" alt=""/></div>
<map name="aclassnz_1_1data_1_1_tensor_ad220de56b18c404611f07f2290cd7e9d_cgraph" id="aclassnz_1_1data_1_1_tensor_ad220de56b18c404611f07f2290cd7e9d_cgraph">
<area shape="rect" title="Fills the tensor&#39;s data with a specified value." alt="" coords="5,47,142,73"/>
<area shape="rect" href="namespacenz_1_1krnl.html#ad136c8a6560a5305984ce0a31bea71bf" title="Kernel function to fill a data array with a given value." alt="" coords="190,47,279,73"/>
<area shape="poly" title=" " alt="" coords="142,57,174,57,174,63,142,63"/>
<area shape="rect" href="classnz_1_1cu_strm_1_1_stream_manager.html#ab4b2eb422e0e1ee44bdfdc0eb94457ce" title="Returns a reference to the singleton instance of the StreamManager." alt="" coords="327,5,512,48"/>
<area shape="poly" title=" " alt="" coords="279,49,311,44,312,49,280,55"/>
<area shape="rect" href="classnz_1_1cu_strm_1_1_stream_manager.html#a46ce59b45de432842454aadf00b93791" title="Asynchronously submits a CUDA kernel with stream&#45;ordered dependency management." alt="" coords="327,72,512,115"/>
<area shape="poly" title=" " alt="" coords="280,65,312,71,311,76,279,71"/>
<area shape="rect" href="classnz_1_1cu_strm_1_1_stream_manager.html#a1de1cf3aadea137faf90a2f9b4b7abe2" title="Acquires CUDA stream from pool using round&#45;robin scheduling." alt="" coords="560,39,746,81"/>
<area shape="poly" title=" " alt="" coords="512,77,544,73,545,78,513,83"/>
<area shape="rect" href="classnz_1_1cu_strm_1_1_stream_manager.html#adb1078a67c6e38932d7d58c2adb05ec0" title="Synchronizes CUDA stream execution until data writes complete." alt="" coords="560,105,746,148"/>
<area shape="poly" title=" " alt="" coords="513,104,545,109,544,114,512,109"/>
</map>
</div>

</div>
</div>
<a id="ad6107b98beb881d0209345185d5ad145" name="ad6107b98beb881d0209345185d5ad145"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6107b98beb881d0209345185d5ad145">&#9670;&#160;</a></span>grad()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Tensor::value_type * nz::data::Tensor::grad </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves a pointer to the gradient data stored in GPU memory. </p>
<dl class="section return"><dt>Returns</dt><dd>A <code>value_type*</code> (pointer to float) pointing to the tensor's gradient data in GPU memory.</dd></dl>
<p>This function provides access to the gradient data of the tensor, stored in GPU memory. If the tensor does not require gradient computation (<code>requires_grad</code> is <code>false</code>), the function throws a <code>std::runtime_error</code>.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>If the tensor does not require gradient computation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>The returned pointer points to GPU memory and cannot be directly dereferenced in CPU code.</li>
<li>Ensure that CUDA synchronization is handled properly before using this pointer in GPU operations.</li>
</ul>
</dd></dl>
<div class="fragment"><div class="line">```cpp</div>
<div class="line"><a class="code hl_class" href="classnz_1_1data_1_1_tensor.html">Tensor</a> tensor({2, 3}, <span class="keyword">true</span>); <span class="comment">// Create a tensor that requires gradients</span></div>
<div class="line"><span class="keywordflow">try</span> {</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span>* grad_data = tensor.grad(); <span class="comment">// Access raw gradient data</span></div>
<div class="line">    <span class="comment">// Use grad_data in CUDA kernels or other GPU-based operations</span></div>
<div class="line">} <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::runtime_error&amp; e) {</div>
<div class="line">    std::cerr &lt;&lt; e.what() &lt;&lt; std::endl; <span class="comment">// Handle error if tensor does not require gradients</span></div>
<div class="line">}</div>
<div class="line">```</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="_tensor_8cu_source.html#l00423">423</a> of file <a class="el" href="_tensor_8cu_source.html">Tensor.cu</a>.</p>

</div>
</div>
<a id="aae7b7714f78f4d366e66f1664d37d36a" name="aae7b7714f78f4d366e66f1664d37d36a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae7b7714f78f4d366e66f1664d37d36a">&#9670;&#160;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nz::data::Tensor::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnz_1_1data_1_1_tensor.html">Tensor</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if two <a class="el" href="classnz_1_1data_1_1_tensor.html" title="A class for representing and manipulating multidimensional arrays (tensors) in GPU memory.">Tensor</a> objects are not equal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The other <a class="el" href="classnz_1_1data_1_1_tensor.html" title="A class for representing and manipulating multidimensional arrays (tensors) in GPU memory.">Tensor</a> object to compare with. Memory flow: device - to - host (the comparison in the <code>operator==</code> function may involve data transfer from device to host).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the two <a class="el" href="classnz_1_1data_1_1_tensor.html" title="A class for representing and manipulating multidimensional arrays (tensors) in GPU memory.">Tensor</a> objects are not equal, false otherwise.</dd></dl>
<p>This function checks the inequality of two <a class="el" href="classnz_1_1data_1_1_tensor.html" title="A class for representing and manipulating multidimensional arrays (tensors) in GPU memory.">Tensor</a> objects. It simply negates the result of the <code>operator==</code> function. So, it relies on the implementation of the <code>operator==</code> to determine the equality of the two Tensors.</p>
<p><b>Memory Management Strategy</b>:</p><ul>
<li>All memory management related to the comparison is handled by the <code>operator==</code> function. This function itself does not allocate or free any memory.</li>
</ul>
<p><b>Exception Handling Mechanism</b>:</p><ul>
<li>Any exceptions that may occur during the comparison are handled by the <code>operator==</code> function. This function does not have its own exception handling mechanism.</li>
</ul>
<p><b>Relationship with Other Components</b>:</p><ul>
<li>Depends entirely on the <code>operator==</code> function of the <code><a class="el" href="classnz_1_1data_1_1_tensor.html" title="A class for representing and manipulating multidimensional arrays (tensors) in GPU memory.">Tensor</a></code> class.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>The time complexity of this function is the same as that of the <code>operator==</code> function, which is O(n) where n is the number of elements in the <a class="el" href="classnz_1_1data_1_1_tensor.html" title="A class for representing and manipulating multidimensional arrays (tensors) in GPU memory.">Tensor</a>.</li>
</ul>
</dd></dl>
<div class="fragment"><div class="line">```cpp</div>
<div class="line"><a class="code hl_class" href="classnz_1_1data_1_1_tensor.html">Tensor</a> tensor1; <span class="comment">// Assume Tensor1 is properly initialized</span></div>
<div class="line"><a class="code hl_class" href="classnz_1_1data_1_1_tensor.html">Tensor</a> tensor2; <span class="comment">// Assume Tensor2 is properly initialized</span></div>
<div class="line"><span class="keywordtype">bool</span> isNotEqual = tensor1 != tensor2;</div>
<div class="line">```</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="_tensor_8cu_source.html#l00506">506</a> of file <a class="el" href="_tensor_8cu_source.html">Tensor.cu</a>.</p>

</div>
</div>
<a id="aaa22ac6f3de75ee92a4307320eda7e87" name="aaa22ac6f3de75ee92a4307320eda7e87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa22ac6f3de75ee92a4307320eda7e87">&#9670;&#160;</a></span>operator*()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnz_1_1data_1_1_tensor.html">Tensor</a> nz::data::Tensor::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnz_1_1data_1_1_tensor.html">Tensor</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs matrix multiplication of two tensors (matrices) and returns the result. </p>
<p>This operator performs matrix multiplication between two tensors (2D matrices) and returns a new tensor containing the result of the multiplication. The number of columns in the first tensor must match the number of rows in the second tensor for matrix multiplication to be valid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The tensor (matrix) to multiply with the current tensor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new tensor containing the result of the matrix multiplication.</dd></dl>
<p>This function checks if the dimensions of the two tensors are compatible for matrix multiplication. If the number of columns in the current tensor does not match the number of rows in the <code>other</code> tensor, it throws an <code>std::invalid_argument</code> exception. It then creates a new tensor to hold the result of the multiplication and uses a CUDA kernel (<code>GeneralMatrixMul</code>) to perform the matrix multiplication in parallel on the GPU.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>If the matrix dimensions are incompatible for multiplication.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>The number of columns in the current tensor (<code>_shape[1]</code>) must match the number of rows in the <code>other</code> tensor (<code>other._shape[0]</code>) for the multiplication to be valid.</li>
<li>This operator uses a CUDA kernel to perform matrix multiplication, and the result is stored in a new tensor, which is returned.</li>
<li>The original tensors are not modified.</li>
</ul>
</dd></dl>
<div class="fragment"><div class="line">```cpp</div>
<div class="line"><a class="code hl_class" href="classnz_1_1data_1_1_tensor.html">Tensor</a> tensor1({2, 3});  <span class="comment">// Create a 2x3 matrix</span></div>
<div class="line"><a class="code hl_class" href="classnz_1_1data_1_1_tensor.html">Tensor</a> tensor2({3, 2});  <span class="comment">// Create a 3x2 matrix</span></div>
<div class="line"><a class="code hl_function" href="#ad0dda0efff93778cab46fd5aa708b983">Tensor</a> result = tensor1 * tensor2;  <span class="comment">// Multiply the matrices (result will be 2x2)</span></div>
<div class="line">```</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="_tensor_8cu_source.html#l00336">336</a> of file <a class="el" href="_tensor_8cu_source.html">Tensor.cu</a>.</p>

</div>
</div>
<a id="a36cd1679c45059de64deeca9152b0288" name="a36cd1679c45059de64deeca9152b0288"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36cd1679c45059de64deeca9152b0288">&#9670;&#160;</a></span>operator+()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnz_1_1data_1_1_tensor.html">Tensor</a> nz::data::Tensor::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnz_1_1data_1_1_tensor.html">Tensor</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds two tensors element-wise and returns the result. </p>
<p>This operator performs element-wise addition of two tensors and returns a new tensor containing the sum of the corresponding elements from the two input tensors.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The tensor to be added to the current tensor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new tensor containing the element-wise sum of the two tensors.</dd></dl>
<p>This function checks if the shapes of the two tensors match. If they do not, it throws an <code>std::invalid_argument</code> exception. The function then creates a new tensor to hold the result of the addition and uses a CUDA kernel (<code>MatrixAddKernel</code>) to compute the sum of the tensors' elements in parallel on the GPU.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>If the shapes of the two tensors do not match.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>The tensors must have the same shape. If they do not, an exception is thrown.</li>
<li>This operator uses a CUDA kernel to perform the element-wise addition, and the result is stored in a new tensor, which is returned.</li>
<li>The original tensors are not modified.</li>
</ul>
</dd></dl>
<div class="fragment"><div class="line">```cpp</div>
<div class="line"><a class="code hl_class" href="classnz_1_1data_1_1_tensor.html">Tensor</a> tensor1({2, 3});</div>
<div class="line"><a class="code hl_class" href="classnz_1_1data_1_1_tensor.html">Tensor</a> tensor2({2, 3});</div>
<div class="line"><a class="code hl_function" href="#ad0dda0efff93778cab46fd5aa708b983">Tensor</a> result = tensor1 + tensor2;  <span class="comment">// Adds the two tensors element-wise</span></div>
<div class="line">```</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="_tensor_8cu_source.html#l00324">324</a> of file <a class="el" href="_tensor_8cu_source.html">Tensor.cu</a>.</p>

</div>
</div>
<a id="ad66d0c0f5d9ecb375e1006bc0aecf404" name="ad66d0c0f5d9ecb375e1006bc0aecf404"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad66d0c0f5d9ecb375e1006bc0aecf404">&#9670;&#160;</a></span>operator-() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnz_1_1data_1_1_tensor.html">Tensor</a> nz::data::Tensor::operator- </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Negates all elements of the tensor and returns the result. </p>
<p>This operator performs element-wise negation of the tensor, returning a new tensor that contains the negated values of the current tensor. Each element in the tensor is multiplied by <code>-1</code> to compute its negation.</p>
<dl class="section return"><dt>Returns</dt><dd>A new tensor containing the element-wise negation of the current tensor.</dd></dl>
<p>This function uses a CUDA kernel (<code>Negation</code>) to perform the negation of each element in the tensor in parallel on the GPU. The result is stored in a new tensor, which is returned.</p>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>This operator does not modify the original tensor; it returns a new tensor with the negated values.</li>
<li>The operation is performed element-wise, meaning each individual element is negated.</li>
<li>The operation utilizes GPU parallelization for efficiency.</li>
</ul>
</dd></dl>
<div class="fragment"><div class="line">```cpp</div>
<div class="line"><a class="code hl_class" href="classnz_1_1data_1_1_tensor.html">Tensor</a> tensor({2, 3});</div>
<div class="line"><a class="code hl_class" href="classnz_1_1data_1_1_tensor.html">Tensor</a> result = -tensor;  <span class="comment">// Negates all elements of the tensor</span></div>
<div class="line">```</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="_tensor_8cu_source.html#l00464">464</a> of file <a class="el" href="_tensor_8cu_source.html">Tensor.cu</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classnz_1_1data_1_1_tensor_ad66d0c0f5d9ecb375e1006bc0aecf404_cgraph.png" border="0" usemap="#aclassnz_1_1data_1_1_tensor_ad66d0c0f5d9ecb375e1006bc0aecf404_cgraph" alt=""/></div>
<map name="aclassnz_1_1data_1_1_tensor_ad66d0c0f5d9ecb375e1006bc0aecf404_cgraph" id="aclassnz_1_1data_1_1_tensor_ad66d0c0f5d9ecb375e1006bc0aecf404_cgraph">
<area shape="rect" title="Negates all elements of the tensor and returns the result." alt="" coords="5,47,180,73"/>
<area shape="rect" href="namespacenz_1_1krnl.html#af7069a420e81babb49b1bc009333d053" title="Kernel function to negate each element of a matrix on the GPU." alt="" coords="228,47,352,73"/>
<area shape="poly" title=" " alt="" coords="180,57,212,57,212,63,180,63"/>
<area shape="rect" href="classnz_1_1cu_strm_1_1_stream_manager.html#ab4b2eb422e0e1ee44bdfdc0eb94457ce" title="Returns a reference to the singleton instance of the StreamManager." alt="" coords="400,5,585,48"/>
<area shape="poly" title=" " alt="" coords="352,47,384,42,385,47,353,52"/>
<area shape="rect" href="classnz_1_1cu_strm_1_1_stream_manager.html#a46ce59b45de432842454aadf00b93791" title="Asynchronously submits a CUDA kernel with stream&#45;ordered dependency management." alt="" coords="400,72,585,115"/>
<area shape="poly" title=" " alt="" coords="353,68,385,73,384,78,352,73"/>
<area shape="rect" href="classnz_1_1cu_strm_1_1_stream_manager.html#a1de1cf3aadea137faf90a2f9b4b7abe2" title="Acquires CUDA stream from pool using round&#45;robin scheduling." alt="" coords="633,39,819,81"/>
<area shape="poly" title=" " alt="" coords="585,77,617,73,618,78,586,83"/>
<area shape="rect" href="classnz_1_1cu_strm_1_1_stream_manager.html#adb1078a67c6e38932d7d58c2adb05ec0" title="Synchronizes CUDA stream execution until data writes complete." alt="" coords="633,105,819,148"/>
<area shape="poly" title=" " alt="" coords="586,104,618,109,617,114,585,109"/>
</map>
</div>

</div>
</div>
<a id="a25cc6634977413df0b67d6e7365448a2" name="a25cc6634977413df0b67d6e7365448a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25cc6634977413df0b67d6e7365448a2">&#9670;&#160;</a></span>operator-() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnz_1_1data_1_1_tensor.html">Tensor</a> nz::data::Tensor::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnz_1_1data_1_1_tensor.html">Tensor</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subtracts one tensor from another element-wise and returns the result. </p>
<p>This operator performs element-wise subtraction of two tensors and returns a new tensor containing the result of subtracting the corresponding elements of the two input tensors.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The tensor to be subtracted from the current tensor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new tensor containing the element-wise difference of the two tensors.</dd></dl>
<p>This function checks if the shapes of the two tensors match. If they do not, it throws an <code>std::invalid_argument</code> exception. The function then creates a new tensor to hold the result of the subtraction and uses a CUDA kernel (<code>MatrixSub</code>) to compute the element-wise subtraction in parallel on the GPU.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>If the shapes of the two tensors do not match.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>The tensors must have the same shape. If they do not, an exception is thrown.</li>
<li>This operator uses a CUDA kernel to perform the element-wise subtraction, and the result is stored in a new tensor, which is returned.</li>
<li>The original tensors are not modified.</li>
</ul>
</dd></dl>
<div class="fragment"><div class="line">```cpp</div>
<div class="line"><a class="code hl_class" href="classnz_1_1data_1_1_tensor.html">Tensor</a> tensor1({2, 3});</div>
<div class="line"><a class="code hl_class" href="classnz_1_1data_1_1_tensor.html">Tensor</a> tensor2({2, 3});</div>
<div class="line"><a class="code hl_function" href="#ad0dda0efff93778cab46fd5aa708b983">Tensor</a> result = tensor1 - tensor2;  <span class="comment">// Subtracts tensor2 from tensor1 element-wise</span></div>
<div class="line">```</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="_tensor_8cu_source.html#l00330">330</a> of file <a class="el" href="_tensor_8cu_source.html">Tensor.cu</a>.</p>

</div>
</div>
<a id="acdb68bf53d38e5a93fdd0effa4c3059a" name="acdb68bf53d38e5a93fdd0effa4c3059a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdb68bf53d38e5a93fdd0effa4c3059a">&#9670;&#160;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnz_1_1data_1_1_tensor.html">Tensor</a> &amp; nz::data::Tensor::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnz_1_1data_1_1_tensor.html">Tensor</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assignment operator for <a class="el" href="classnz_1_1data_1_1_tensor.html" title="A class for representing and manipulating multidimensional arrays (tensors) in GPU memory.">Tensor</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The <a class="el" href="classnz_1_1data_1_1_tensor.html" title="A class for representing and manipulating multidimensional arrays (tensors) in GPU memory.">Tensor</a> object to assign from.</td></tr>
  </table>
  </dd>
</dl>
<p>Performs a deep copy of the tensor, including its shape, data, and gradient (if applicable).</p>
<dl class="section return"><dt>Returns</dt><dd>A reference to the assigned <a class="el" href="classnz_1_1data_1_1_tensor.html" title="A class for representing and manipulating multidimensional arrays (tensors) in GPU memory.">Tensor</a> object. </dd></dl>

<p class="definition">Definition at line <a class="el" href="_tensor_8cu_source.html#l00173">173</a> of file <a class="el" href="_tensor_8cu_source.html">Tensor.cu</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classnz_1_1data_1_1_tensor_acdb68bf53d38e5a93fdd0effa4c3059a_cgraph.png" border="0" usemap="#aclassnz_1_1data_1_1_tensor_acdb68bf53d38e5a93fdd0effa4c3059a_cgraph" alt=""/></div>
<map name="aclassnz_1_1data_1_1_tensor_acdb68bf53d38e5a93fdd0effa4c3059a_cgraph" id="aclassnz_1_1data_1_1_tensor_acdb68bf53d38e5a93fdd0effa4c3059a_cgraph">
<area shape="rect" title="Assignment operator for Tensor." alt="" coords="5,113,184,140"/>
<area shape="rect" href="classnz_1_1cu_strm_1_1_stream_manager.html#a785cf34395067f425e032d9bd5e1fa20" title="Frees the CUDA device memory pointed to by the given pointer." alt="" coords="232,5,417,48"/>
<area shape="poly" title=" " alt="" coords="121,110,231,58,245,52,247,56,233,62,123,115"/>
<area shape="rect" href="classnz_1_1cu_strm_1_1_stream_manager.html#ab4b2eb422e0e1ee44bdfdc0eb94457ce" title="Returns a reference to the singleton instance of the StreamManager." alt="" coords="232,72,417,115"/>
<area shape="poly" title=" " alt="" coords="184,111,216,106,216,112,185,116"/>
<area shape="rect" href="classnz_1_1cu_strm_1_1_stream_manager.html#a97f78a2d43f6e0508c82d4f3b629de96" title="Asynchronously allocates device memory for type&#45;specific data with stream&#45;ordered dependency tracking..." alt="" coords="232,139,417,181"/>
<area shape="poly" title=" " alt="" coords="185,137,216,142,216,147,184,142"/>
<area shape="rect" href="classnz_1_1cu_strm_1_1_stream_manager.html#afa38d5c6db0e6b48c8f74ce8ad0df2bc" title="Asynchronously copies data between CUDA device and host memory based on the specified memory copy kin..." alt="" coords="232,205,417,248"/>
<area shape="poly" title=" " alt="" coords="123,138,233,191,247,197,245,202,231,196,121,143"/>
<area shape="rect" href="classnz_1_1cu_strm_1_1_stream_manager.html#abe439fa00c0bd369c0b2345b095ed5af" title="Synchronizes host thread with completion events for a specific data object." alt="" coords="465,5,650,48"/>
<area shape="poly" title=" " alt="" coords="417,24,449,24,449,29,417,29"/>
<area shape="rect" href="classnz_1_1cu_strm_1_1_stream_manager.html#a1de1cf3aadea137faf90a2f9b4b7abe2" title="Acquires CUDA stream from pool using round&#45;robin scheduling." alt="" coords="465,139,650,181"/>
<area shape="poly" title=" " alt="" coords="417,157,449,157,449,163,417,163"/>
<area shape="poly" title=" " alt="" coords="400,202,465,184,466,189,402,207"/>
<area shape="rect" href="classnz_1_1cu_strm_1_1_stream_manager.html#adb1078a67c6e38932d7d58c2adb05ec0" title="Synchronizes CUDA stream execution until data writes complete." alt="" coords="465,205,650,248"/>
<area shape="poly" title=" " alt="" coords="417,224,449,224,449,229,417,229"/>
</map>
</div>

</div>
</div>
<a id="a26b24cc132d14e054b3c25923516d781" name="a26b24cc132d14e054b3c25923516d781"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26b24cc132d14e054b3c25923516d781">&#9670;&#160;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnz_1_1data_1_1_tensor.html">Tensor</a> &amp; nz::data::Tensor::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnz_1_1data_1_1_tensor.html">Tensor</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move assignment operator for <a class="el" href="classnz_1_1data_1_1_tensor.html" title="A class for representing and manipulating multidimensional arrays (tensors) in GPU memory.">Tensor</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The <a class="el" href="classnz_1_1data_1_1_tensor.html" title="A class for representing and manipulating multidimensional arrays (tensors) in GPU memory.">Tensor</a> object to move from.</td></tr>
  </table>
  </dd>
</dl>
<p>Moves the tensor data and ownership of the GPU memory to the new object.</p>
<dl class="section return"><dt>Returns</dt><dd>A reference to the assigned <a class="el" href="classnz_1_1data_1_1_tensor.html" title="A class for representing and manipulating multidimensional arrays (tensors) in GPU memory.">Tensor</a> object. </dd></dl>

<p class="definition">Definition at line <a class="el" href="_tensor_8cu_source.html#l00192">192</a> of file <a class="el" href="_tensor_8cu_source.html">Tensor.cu</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classnz_1_1data_1_1_tensor_a26b24cc132d14e054b3c25923516d781_cgraph.png" border="0" usemap="#aclassnz_1_1data_1_1_tensor_a26b24cc132d14e054b3c25923516d781_cgraph" alt=""/></div>
<map name="aclassnz_1_1data_1_1_tensor_a26b24cc132d14e054b3c25923516d781_cgraph" id="aclassnz_1_1data_1_1_tensor_a26b24cc132d14e054b3c25923516d781_cgraph">
<area shape="rect" title="Move assignment operator for Tensor." alt="" coords="5,47,184,73"/>
<area shape="rect" href="classnz_1_1cu_strm_1_1_stream_manager.html#a785cf34395067f425e032d9bd5e1fa20" title="Frees the CUDA device memory pointed to by the given pointer." alt="" coords="232,5,417,48"/>
<area shape="poly" title=" " alt="" coords="184,44,216,40,216,45,185,50"/>
<area shape="rect" href="classnz_1_1cu_strm_1_1_stream_manager.html#ab4b2eb422e0e1ee44bdfdc0eb94457ce" title="Returns a reference to the singleton instance of the StreamManager." alt="" coords="232,72,417,115"/>
<area shape="poly" title=" " alt="" coords="185,70,216,75,216,80,184,76"/>
<area shape="rect" href="classnz_1_1cu_strm_1_1_stream_manager.html#abe439fa00c0bd369c0b2345b095ed5af" title="Synchronizes host thread with completion events for a specific data object." alt="" coords="465,5,650,48"/>
<area shape="poly" title=" " alt="" coords="417,24,449,24,449,29,417,29"/>
</map>
</div>

</div>
</div>
<a id="a92c7313608326bb4123d6f08341a6d80" name="a92c7313608326bb4123d6f08341a6d80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92c7313608326bb4123d6f08341a6d80">&#9670;&#160;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nz::data::Tensor::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnz_1_1data_1_1_tensor.html">Tensor</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if two <a class="el" href="classnz_1_1data_1_1_tensor.html" title="A class for representing and manipulating multidimensional arrays (tensors) in GPU memory.">Tensor</a> objects are equal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The other <a class="el" href="classnz_1_1data_1_1_tensor.html" title="A class for representing and manipulating multidimensional arrays (tensors) in GPU memory.">Tensor</a> object to compare with. Memory flow: device - to - host (data is copied from device to host for comparison).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the two <a class="el" href="classnz_1_1data_1_1_tensor.html" title="A class for representing and manipulating multidimensional arrays (tensors) in GPU memory.">Tensor</a> objects are equal, false otherwise.</dd></dl>
<p>This function compares two <a class="el" href="classnz_1_1data_1_1_tensor.html" title="A class for representing and manipulating multidimensional arrays (tensors) in GPU memory.">Tensor</a> objects for equality. First, it checks if the <code>_requires_grad</code> flags of the two Tensors are the same. If they differ, the function immediately returns false. Then, it compares the shapes of the two Tensors. If the shapes are not equal, the function also returns false.</p>
<p>After that, it allocates host memory for temporary storage of the data from the device memory of both Tensors. It copies the data from the device to the host and compares each element one by one. If any element in the data differs, it frees the allocated host memory and returns false.</p>
<p>If the <code>_requires_grad</code> flag is set to true, it repeats the same process for the gradients of the Tensors. If any element in the gradients differs, it frees the allocated host memory and returns false.</p>
<p>Finally, if all comparisons pass, it frees the allocated host memory and returns true.</p>
<p><b>Memory Management Strategy</b>:</p><ul>
<li>Two arrays <code>temp</code> and <code>temp_other</code> of size <code>_size</code> are dynamically allocated on the host using <code>new[]</code>. They are freed using <code>delete[]</code> either when a difference is found or at the end of the function.</li>
</ul>
<p><b>Exception Handling Mechanism</b>:</p><ul>
<li>The CUDA memory copy operations (<code>cudaMemcpy</code>) may return error codes indicating failures. It is assumed that the calling code or the CUDA runtime will handle these errors appropriately.</li>
</ul>
<p><b>Relationship with Other Components</b>:</p><ul>
<li>Depends on the <code>_requires_grad</code>, <code>_shape</code>, <code>_size</code>, <code>_data</code>, and <code>_grad</code> members of the <code><a class="el" href="classnz_1_1data_1_1_tensor.html" title="A class for representing and manipulating multidimensional arrays (tensors) in GPU memory.">Tensor</a></code> class.</li>
<li>Uses CUDA memory copy operations (<code>cudaMemcpy</code>) to transfer data from device to host.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>Be aware of potential CUDA errors during memory copy operations and handle them appropriately in the calling code.</li>
<li>The function has a time complexity of O(n), where n is the number of elements in the <a class="el" href="classnz_1_1data_1_1_tensor.html" title="A class for representing and manipulating multidimensional arrays (tensors) in GPU memory.">Tensor</a>, due to the element - by - element comparison.</li>
</ul>
</dd></dl>
<div class="fragment"><div class="line">```cpp</div>
<div class="line"><a class="code hl_class" href="classnz_1_1data_1_1_tensor.html">Tensor</a> tensor1; <span class="comment">// Assume Tensor1 is properly initialized</span></div>
<div class="line"><a class="code hl_class" href="classnz_1_1data_1_1_tensor.html">Tensor</a> tensor2; <span class="comment">// Assume Tensor2 is properly initialized</span></div>
<div class="line"><span class="keywordtype">bool</span> isEqual = tensor1 == tensor2;</div>
<div class="line">```</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="_tensor_8cu_source.html#l00472">472</a> of file <a class="el" href="_tensor_8cu_source.html">Tensor.cu</a>.</p>

</div>
</div>
<a id="a2b2309d5428331f2e6f88037bb123c8f" name="a2b2309d5428331f2e6f88037bb123c8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b2309d5428331f2e6f88037bb123c8f">&#9670;&#160;</a></span>print()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; nz::data::Tensor::print </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints the tensor data to an output stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>The output stream to which the tensor data will be written (host-to-host).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The output stream after the tensor data has been written.</dd></dl>
<p>This function copies the tensor data from device memory to host memory using <code>cudaMemcpy</code>. It then allocates memory on the host using <code>malloc</code> to hold the copied data. After printing the data to the output stream, it frees the allocated host memory using <code>free</code>. The function does not throw any exceptions under normal circumstances. If <code>cudaMemcpy</code> fails, the behavior depends on the <code>CHECK</code> macro, which is assumed to handle errors appropriately.</p>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>The time complexity of this function is O(n), where n is the total number of elements in the tensor.</li>
<li>Ensure that the CUDA environment is properly initialized before calling this function.</li>
</ul>
</dd></dl>
<div class="fragment"><div class="line">```cpp</div>
<div class="line"><a class="code hl_class" href="classnz_1_1data_1_1_tensor.html">Tensor</a> tensor;</div>
<div class="line">std::ostringstream oss;</div>
<div class="line">tensor.<a class="code hl_function" href="#a2b2309d5428331f2e6f88037bb123c8f">print</a>(oss);</div>
<div class="line">std::cout &lt;&lt; oss.str();</div>
<div class="line">```</div>
<div class="ttc" id="aclassnz_1_1data_1_1_tensor_html_a2b2309d5428331f2e6f88037bb123c8f"><div class="ttname"><a href="#a2b2309d5428331f2e6f88037bb123c8f">nz::data::Tensor::print</a></div><div class="ttdeci">std::ostream &amp; print(std::ostream &amp;os) const</div><div class="ttdoc">Prints the tensor data to an output stream.</div><div class="ttdef"><b>Definition</b> <a href="_tensor_8cu_source.html#l00246">Tensor.cu:246</a></div></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="_tensor_8cu_source.html#l00246">246</a> of file <a class="el" href="_tensor_8cu_source.html">Tensor.cu</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classnz_1_1data_1_1_tensor_a2b2309d5428331f2e6f88037bb123c8f_cgraph.png" border="0" usemap="#aclassnz_1_1data_1_1_tensor_a2b2309d5428331f2e6f88037bb123c8f_cgraph" alt=""/></div>
<map name="aclassnz_1_1data_1_1_tensor_a2b2309d5428331f2e6f88037bb123c8f_cgraph" id="aclassnz_1_1data_1_1_tensor_a2b2309d5428331f2e6f88037bb123c8f_cgraph">
<area shape="rect" title="Prints the tensor data to an output stream." alt="" coords="5,97,154,124"/>
<area shape="rect" href="classnz_1_1data_1_1_tensor.html#a38ba233ef49f34620297f96edd962c55" title="Retrieves a pointer to the tensor&#39;s data stored in GPU memory." alt="" coords="220,5,368,32"/>
<area shape="poly" title=" " alt="" coords="101,94,146,68,201,42,220,35,222,40,203,46,148,73,104,99"/>
<area shape="rect" href="classnz_1_1cu_strm_1_1_stream_manager.html#ab4b2eb422e0e1ee44bdfdc0eb94457ce" title="Returns a reference to the singleton instance of the StreamManager." alt="" coords="202,56,387,99"/>
<area shape="poly" title=" " alt="" coords="153,97,186,91,187,97,154,102"/>
<area shape="rect" href="classnz_1_1cu_strm_1_1_stream_manager.html#afa38d5c6db0e6b48c8f74ce8ad0df2bc" title="Asynchronously copies data between CUDA device and host memory based on the specified memory copy kin..." alt="" coords="202,123,387,165"/>
<area shape="poly" title=" " alt="" coords="154,120,187,125,186,130,153,125"/>
<area shape="rect" href="classnz_1_1cu_strm_1_1_stream_manager.html#abe439fa00c0bd369c0b2345b095ed5af" title="Synchronizes host thread with completion events for a specific data object." alt="" coords="202,189,387,232"/>
<area shape="poly" title=" " alt="" coords="105,122,203,175,216,181,214,186,201,180,102,127"/>
<area shape="rect" href="classnz_1_1cu_strm_1_1_stream_manager.html#a1de1cf3aadea137faf90a2f9b4b7abe2" title="Acquires CUDA stream from pool using round&#45;robin scheduling." alt="" coords="435,89,620,132"/>
<area shape="poly" title=" " alt="" coords="387,128,419,123,420,129,388,133"/>
<area shape="rect" href="classnz_1_1cu_strm_1_1_stream_manager.html#adb1078a67c6e38932d7d58c2adb05ec0" title="Synchronizes CUDA stream execution until data writes complete." alt="" coords="435,156,620,199"/>
<area shape="poly" title=" " alt="" coords="388,155,420,159,419,165,387,160"/>
</map>
</div>

</div>
</div>
<a id="a4b02ed4d2afec1ce75931201af181e14" name="a4b02ed4d2afec1ce75931201af181e14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b02ed4d2afec1ce75931201af181e14">&#9670;&#160;</a></span>printGrad()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; nz::data::Tensor::printGrad </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints the gradient values of the tensor to an output stream. </p>
<p>This function prints the gradient of the tensor (<code>_grad</code>) to the provided output stream (<code>os</code>). The gradient data is first copied from GPU memory to host memory, and then it is printed in a 2D matrix format where each row represents one dimension of the gradient. Each element in the gradient is printed, separated by a space.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>The output stream to which the gradient will be printed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The same output stream (<code>os</code>), allowing for chaining of stream operations.</dd></dl>
<p>This function performs the following steps:</p><ol type="1">
<li>It allocates memory on the host and copies the gradient data from the device to the host.</li>
<li>It uses <code>std::copy</code> to print the gradient values in a matrix format (row by row).</li>
<li>The function prints each row of the gradient, with each value separated by a space.</li>
</ol>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>This function assumes that the gradient data has already been allocated and is valid.</li>
<li>The gradient is copied from device (GPU) memory to host (CPU) memory for printing, which can be inefficient for large tensors.</li>
<li>The function prints each row of the gradient tensor, enclosed in square brackets, with the elements separated by spaces.</li>
</ul>
</dd></dl>
<div class="fragment"><div class="line">```cpp</div>
<div class="line"><a class="code hl_class" href="classnz_1_1data_1_1_tensor.html">Tensor</a> tensor({2, 3}, <span class="keyword">true</span>);  <span class="comment">// Create a tensor with gradient support</span></div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Gradient: &quot;</span> &lt;&lt; std::endl;</div>
<div class="line">tensor.<a class="code hl_function" href="#a4b02ed4d2afec1ce75931201af181e14">printGrad</a>(std::cout);  <span class="comment">// Print the gradient of the tensor</span></div>
<div class="line">```</div>
<div class="ttc" id="aclassnz_1_1data_1_1_tensor_html_a4b02ed4d2afec1ce75931201af181e14"><div class="ttname"><a href="#a4b02ed4d2afec1ce75931201af181e14">nz::data::Tensor::printGrad</a></div><div class="ttdeci">std::ostream &amp; printGrad(std::ostream &amp;os) const</div><div class="ttdoc">Prints the gradient values of the tensor to an output stream.</div><div class="ttdef"><b>Definition</b> <a href="_tensor_8cu_source.html#l00430">Tensor.cu:430</a></div></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="_tensor_8cu_source.html#l00430">430</a> of file <a class="el" href="_tensor_8cu_source.html">Tensor.cu</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classnz_1_1data_1_1_tensor_a4b02ed4d2afec1ce75931201af181e14_cgraph.png" border="0" usemap="#aclassnz_1_1data_1_1_tensor_a4b02ed4d2afec1ce75931201af181e14_cgraph" alt=""/></div>
<map name="aclassnz_1_1data_1_1_tensor_a4b02ed4d2afec1ce75931201af181e14_cgraph" id="aclassnz_1_1data_1_1_tensor_a4b02ed4d2afec1ce75931201af181e14_cgraph">
<area shape="rect" title="Prints the gradient values of the tensor to an output stream." alt="" coords="5,97,182,124"/>
<area shape="rect" href="classnz_1_1data_1_1_tensor.html#a38ba233ef49f34620297f96edd962c55" title="Retrieves a pointer to the tensor&#39;s data stored in GPU memory." alt="" coords="248,5,396,32"/>
<area shape="poly" title=" " alt="" coords="118,94,169,68,229,42,249,34,251,39,231,46,171,73,121,99"/>
<area shape="rect" href="classnz_1_1cu_strm_1_1_stream_manager.html#ab4b2eb422e0e1ee44bdfdc0eb94457ce" title="Returns a reference to the singleton instance of the StreamManager." alt="" coords="230,56,415,99"/>
<area shape="poly" title=" " alt="" coords="182,95,214,90,215,96,183,100"/>
<area shape="rect" href="classnz_1_1cu_strm_1_1_stream_manager.html#afa38d5c6db0e6b48c8f74ce8ad0df2bc" title="Asynchronously copies data between CUDA device and host memory based on the specified memory copy kin..." alt="" coords="230,123,415,165"/>
<area shape="poly" title=" " alt="" coords="183,121,215,126,214,131,182,126"/>
<area shape="rect" href="classnz_1_1cu_strm_1_1_stream_manager.html#abe439fa00c0bd369c0b2345b095ed5af" title="Synchronizes host thread with completion events for a specific data object." alt="" coords="230,189,415,232"/>
<area shape="poly" title=" " alt="" coords="122,122,231,175,245,181,243,186,229,180,120,127"/>
<area shape="rect" href="classnz_1_1cu_strm_1_1_stream_manager.html#a1de1cf3aadea137faf90a2f9b4b7abe2" title="Acquires CUDA stream from pool using round&#45;robin scheduling." alt="" coords="463,89,648,132"/>
<area shape="poly" title=" " alt="" coords="415,128,447,123,448,129,416,133"/>
<area shape="rect" href="classnz_1_1cu_strm_1_1_stream_manager.html#adb1078a67c6e38932d7d58c2adb05ec0" title="Synchronizes CUDA stream execution until data writes complete." alt="" coords="463,156,648,199"/>
<area shape="poly" title=" " alt="" coords="416,155,448,159,447,165,415,160"/>
</map>
</div>

</div>
</div>
<a id="a7a9f1d5fae2989181645e5f59f7666d8" name="a7a9f1d5fae2989181645e5f59f7666d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a9f1d5fae2989181645e5f59f7666d8">&#9670;&#160;</a></span>randomize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nz::data::Tensor::randomize </td>
          <td>(</td>
          <td class="paramtype">unsigned long long</td>          <td class="paramname"><span class="paramname"><em>seed</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Randomizes the tensor's data with a uniform distribution. </p>
<p>This function fills the tensor's data with random values sampled from a uniform distribution in the range [0, 1). The random number generator is initialized using the specified seed to ensure reproducibility. The function uses the <code>curand</code> library to generate random numbers on the GPU.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seed</td><td>A <code>unsigned long long</code> value used to initialize the random number generator. The same seed will produce the same sequence of random numbers, ensuring reproducibility.</td></tr>
  </table>
  </dd>
</dl>
<p>This function performs the following steps:</p><ol type="1">
<li>It creates a random number generator using <code>curandCreateGenerator</code>.</li>
<li>It sets the seed for the random number generator using <code>curandSetPseudoRandomGeneratorSeed</code>.</li>
<li>It generates uniform random numbers in the range [0, 1) and fills the tensor's data with these values.</li>
</ol>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>The generated random numbers are uniformly distributed in the range [0, 1).</li>
</ul>
</dd></dl>
<div class="fragment"><div class="line">```cpp</div>
<div class="line"><a class="code hl_class" href="classnz_1_1data_1_1_tensor.html">Tensor</a> tensor({2, 3});  <span class="comment">// Create a tensor with shape 2x3</span></div>
<div class="line">tensor.<a class="code hl_function" href="#a7a9f1d5fae2989181645e5f59f7666d8">randomize</a>(12345);  <span class="comment">// Randomize tensor&#39;s data with a seed of 12345</span></div>
<div class="line">```</div>
<div class="ttc" id="aclassnz_1_1data_1_1_tensor_html_a7a9f1d5fae2989181645e5f59f7666d8"><div class="ttname"><a href="#a7a9f1d5fae2989181645e5f59f7666d8">nz::data::Tensor::randomize</a></div><div class="ttdeci">void randomize(unsigned long long seed=0) const</div><div class="ttdoc">Randomizes the tensor's data with a uniform distribution.</div><div class="ttdef"><b>Definition</b> <a href="_tensor_8cu_source.html#l00292">Tensor.cu:292</a></div></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="_tensor_8cu_source.html#l00292">292</a> of file <a class="el" href="_tensor_8cu_source.html">Tensor.cu</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classnz_1_1data_1_1_tensor_a7a9f1d5fae2989181645e5f59f7666d8_cgraph.png" border="0" usemap="#aclassnz_1_1data_1_1_tensor_a7a9f1d5fae2989181645e5f59f7666d8_cgraph" alt=""/></div>
<map name="aclassnz_1_1data_1_1_tensor_a7a9f1d5fae2989181645e5f59f7666d8_cgraph" id="aclassnz_1_1data_1_1_tensor_a7a9f1d5fae2989181645e5f59f7666d8_cgraph">
<area shape="rect" title="Randomizes the tensor&#39;s data with a uniform distribution." alt="" coords="5,47,189,73"/>
<area shape="rect" href="classnz_1_1cu_strm_1_1_stream_manager.html#ab4b2eb422e0e1ee44bdfdc0eb94457ce" title="Returns a reference to the singleton instance of the StreamManager." alt="" coords="237,5,422,48"/>
<area shape="poly" title=" " alt="" coords="189,44,221,40,221,45,189,49"/>
<area shape="rect" href="classnz_1_1cu_strm_1_1_stream_manager.html#a731986c2c4ecd056562eaddadef46df8" title="Generates uniformly distributed random numbers on GPU using CURAND." alt="" coords="237,72,422,115"/>
<area shape="poly" title=" " alt="" coords="189,71,221,75,221,80,189,76"/>
<area shape="rect" href="classnz_1_1cu_strm_1_1_stream_manager.html#a1de1cf3aadea137faf90a2f9b4b7abe2" title="Acquires CUDA stream from pool using round&#45;robin scheduling." alt="" coords="470,39,655,81"/>
<area shape="poly" title=" " alt="" coords="422,77,454,73,455,78,423,83"/>
<area shape="rect" href="classnz_1_1cu_strm_1_1_stream_manager.html#adb1078a67c6e38932d7d58c2adb05ec0" title="Synchronizes CUDA stream execution until data writes complete." alt="" coords="470,105,655,148"/>
<area shape="poly" title=" " alt="" coords="423,104,455,109,454,114,422,109"/>
</map>
</div>

</div>
</div>
<a id="a178a2240cd5d441be508490b2613fc55" name="a178a2240cd5d441be508490b2613fc55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a178a2240cd5d441be508490b2613fc55">&#9670;&#160;</a></span>recip()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nz::data::Tensor::recip </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the reciprocal (1/x) of each element in the tensor and updates the tensor in-place. </p>
<p>This function computes the reciprocal (1/x) of each element in the tensor and stores the results back into the original tensor. The operation is performed element-wise, where each element of the tensor is replaced by its reciprocal.</p>
<p>The function utilizes a temporary buffer allocated on the GPU to store the intermediate reciprocal values. After the computation, the updated data is copied back to the original tensor in GPU memory.</p>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>This operation is performed element-wise on the tensor's data.</li>
<li>The original tensor is updated with the computed reciprocal values.</li>
<li>The function uses GPU memory for efficient parallel computation.</li>
</ul>
</dd></dl>
<div class="fragment"><div class="line">```cpp</div>
<div class="line"><a class="code hl_class" href="classnz_1_1data_1_1_tensor.html">Tensor</a> tensor({2, 3});</div>
<div class="line">tensor.<a class="code hl_function" href="#a178a2240cd5d441be508490b2613fc55">recip</a>();  <span class="comment">// Computes the reciprocal of each element in the tensor</span></div>
<div class="line">```</div>
<div class="ttc" id="aclassnz_1_1data_1_1_tensor_html_a178a2240cd5d441be508490b2613fc55"><div class="ttname"><a href="#a178a2240cd5d441be508490b2613fc55">nz::data::Tensor::recip</a></div><div class="ttdeci">void recip() const</div><div class="ttdoc">Computes the reciprocal (1/x) of each element in the tensor and updates the tensor in-place.</div><div class="ttdef"><b>Definition</b> <a href="_tensor_8cu_source.html#l00510">Tensor.cu:510</a></div></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="_tensor_8cu_source.html#l00510">510</a> of file <a class="el" href="_tensor_8cu_source.html">Tensor.cu</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classnz_1_1data_1_1_tensor_a178a2240cd5d441be508490b2613fc55_cgraph.png" border="0" usemap="#aclassnz_1_1data_1_1_tensor_a178a2240cd5d441be508490b2613fc55_cgraph" alt=""/></div>
<map name="aclassnz_1_1data_1_1_tensor_a178a2240cd5d441be508490b2613fc55_cgraph" id="aclassnz_1_1data_1_1_tensor_a178a2240cd5d441be508490b2613fc55_cgraph">
<area shape="rect" title="Computes the reciprocal (1/x) of each element in the tensor and updates the tensor in&#45;place." alt="" coords="5,160,157,187"/>
<area shape="rect" href="classnz_1_1data_1_1_tensor.html#a38ba233ef49f34620297f96edd962c55" title="Retrieves a pointer to the tensor&#39;s data stored in GPU memory." alt="" coords="223,5,372,32"/>
<area shape="poly" title=" " alt="" coords="89,158,134,102,166,69,203,42,214,36,217,41,206,46,170,73,138,105,93,161"/>
<area shape="rect" href="classnz_1_1cu_strm_1_1_stream_manager.html#a785cf34395067f425e032d9bd5e1fa20" title="Frees the CUDA device memory pointed to by the given pointer." alt="" coords="205,56,390,99"/>
<area shape="poly" title=" " alt="" coords="106,157,204,108,217,102,220,107,206,113,108,162"/>
<area shape="rect" href="classnz_1_1cu_strm_1_1_stream_manager.html#ab4b2eb422e0e1ee44bdfdc0eb94457ce" title="Returns a reference to the singleton instance of the StreamManager." alt="" coords="438,181,623,224"/>
<area shape="poly" title=" " alt="" coords="157,176,423,193,423,198,157,181"/>
<area shape="rect" href="classnz_1_1cu_strm_1_1_stream_manager.html#a97f78a2d43f6e0508c82d4f3b629de96" title="Asynchronously allocates device memory for type&#45;specific data with stream&#45;ordered dependency tracking..." alt="" coords="205,123,390,165"/>
<area shape="poly" title=" " alt="" coords="157,160,189,156,189,161,157,166"/>
<area shape="rect" href="classnz_1_1cu_strm_1_1_stream_manager.html#afa38d5c6db0e6b48c8f74ce8ad0df2bc" title="Asynchronously copies data between CUDA device and host memory based on the specified memory copy kin..." alt="" coords="438,315,623,357"/>
<area shape="poly" title=" " alt="" coords="96,185,141,231,172,256,206,276,259,297,315,312,423,329,422,334,314,317,257,302,203,281,169,260,137,235,92,189"/>
<area shape="rect" href="namespacenz_1_1krnl.html#adc047e65307dbc711235f637227b7d10" title="Kernel function to compute the reciprocal of each element of a matrix on the GPU." alt="" coords="244,240,350,267"/>
<area shape="poly" title=" " alt="" coords="118,185,206,219,242,232,240,237,204,224,116,190"/>
<area shape="rect" href="classnz_1_1cu_strm_1_1_stream_manager.html#abe439fa00c0bd369c0b2345b095ed5af" title="Synchronizes host thread with completion events for a specific data object." alt="" coords="438,56,623,99"/>
<area shape="poly" title=" " alt="" coords="390,75,422,75,422,80,390,80"/>
<area shape="rect" href="classnz_1_1cu_strm_1_1_stream_manager.html#a1de1cf3aadea137faf90a2f9b4b7abe2" title="Acquires CUDA stream from pool using round&#45;robin scheduling." alt="" coords="671,248,857,291"/>
<area shape="poly" title=" " alt="" coords="390,136,444,136,504,140,565,150,624,167,655,181,683,198,731,235,728,240,680,202,652,185,622,172,564,155,503,146,444,141,390,141"/>
<area shape="poly" title=" " alt="" coords="607,312,671,293,673,298,608,317"/>
<area shape="rect" href="classnz_1_1cu_strm_1_1_stream_manager.html#adb1078a67c6e38932d7d58c2adb05ec0" title="Synchronizes CUDA stream execution until data writes complete." alt="" coords="671,315,857,357"/>
<area shape="poly" title=" " alt="" coords="624,333,656,333,656,339,624,339"/>
<area shape="poly" title=" " alt="" coords="350,239,422,224,423,229,352,244"/>
<area shape="rect" href="classnz_1_1cu_strm_1_1_stream_manager.html#a46ce59b45de432842454aadf00b93791" title="Asynchronously submits a CUDA kernel with stream&#45;ordered dependency management." alt="" coords="438,248,623,291"/>
<area shape="poly" title=" " alt="" coords="351,254,422,259,422,265,351,260"/>
<area shape="poly" title=" " alt="" coords="624,267,656,267,656,272,624,272"/>
<area shape="poly" title=" " alt="" coords="608,289,673,307,671,312,607,294"/>
</map>
</div>

</div>
</div>
<a id="a7cbc6dd248b882c95840835d0deaae1c" name="a7cbc6dd248b882c95840835d0deaae1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cbc6dd248b882c95840835d0deaae1c">&#9670;&#160;</a></span>requiresGrad()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool nz::data::Tensor::requiresGrad </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether the tensor requires gradient computation. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the tensor requires gradient computation, <code>false</code> otherwise.</dd></dl>
<p>This function allows you to query whether the tensor is marked for gradient tracking, which is essential for backpropagation in neural networks. By default, tensors do not require gradients unless explicitly specified during construction or via <code>setRequiresGrad</code>. </p>

<p class="definition">Definition at line <a class="el" href="_tensor_8cu_source.html#l00218">218</a> of file <a class="el" href="_tensor_8cu_source.html">Tensor.cu</a>.</p>

</div>
</div>
<a id="a877f9f2704e39100142d81d289ddc3f2" name="a877f9f2704e39100142d81d289ddc3f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a877f9f2704e39100142d81d289ddc3f2">&#9670;&#160;</a></span>reshape()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nz::data::Tensor::reshape </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnz_1_1data_1_1_dimension.html">shape_type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>shape</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reshapes the tensor to the specified shape. </p>
<p>This function changes the shape of the tensor, adjusting the layout of the data in memory. If the new shape has more elements than the current shape, the extra elements will be initialized to zero. If the new shape has fewer elements, the excess elements will be discarded.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shape</td><td>A <code>shape_type</code> (alias for <code>std::vector&lt;int&gt;</code>) representing the new dimensions of the tensor. The total number of elements in the new shape can be larger or smaller than the current shape.</td></tr>
  </table>
  </dd>
</dl>
<p>This function performs the following steps:</p><ol type="1">
<li>It updates the tensor's shape to the new dimensions.</li>
<li>If the new shape requires more elements than the original shape, the new elements are initialized to zero.</li>
<li>If the new shape requires fewer elements, the excess data is discarded.</li>
</ol>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>This function does not reallocate memory. It simply adjusts how the existing data is interpreted based on the new shape.</li>
<li>If the new shape has more elements than the current tensor, the excess elements will be initialized to zero.</li>
<li>If the new shape has fewer elements, data beyond the new size will be discarded.</li>
</ul>
</dd></dl>
<div class="fragment"><div class="line">```cpp</div>
<div class="line"><a class="code hl_class" href="classnz_1_1data_1_1_tensor.html">Tensor</a> tensor({2, 3});  <span class="comment">// Create a tensor with shape 2x3</span></div>
<div class="line">tensor.<a class="code hl_function" href="#a877f9f2704e39100142d81d289ddc3f2">reshape</a>(std::vector&lt;int&gt;({3, 2}));  <span class="comment">// Reshape the tensor to shape 3x2, unused elements will be filled with zeros</span></div>
<div class="line">```</div>
<div class="ttc" id="aclassnz_1_1data_1_1_tensor_html_a877f9f2704e39100142d81d289ddc3f2"><div class="ttname"><a href="#a877f9f2704e39100142d81d289ddc3f2">nz::data::Tensor::reshape</a></div><div class="ttdeci">void reshape(const shape_type &amp;shape)</div><div class="ttdoc">Reshapes the tensor to the specified shape.</div><div class="ttdef"><b>Definition</b> <a href="_tensor_8cu_source.html#l00351">Tensor.cu:351</a></div></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="_tensor_8cu_source.html#l00351">351</a> of file <a class="el" href="_tensor_8cu_source.html">Tensor.cu</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classnz_1_1data_1_1_tensor_a877f9f2704e39100142d81d289ddc3f2_cgraph.png" border="0" usemap="#aclassnz_1_1data_1_1_tensor_a877f9f2704e39100142d81d289ddc3f2_cgraph" alt=""/></div>
<map name="aclassnz_1_1data_1_1_tensor_a877f9f2704e39100142d81d289ddc3f2_cgraph" id="aclassnz_1_1data_1_1_tensor_a877f9f2704e39100142d81d289ddc3f2_cgraph">
<area shape="rect" title="Reshapes the tensor to the specified shape." alt="" coords="5,213,175,240"/>
<area shape="rect" href="classnz_1_1cu_strm_1_1_stream_manager.html#a785cf34395067f425e032d9bd5e1fa20" title="Frees the CUDA device memory pointed to by the given pointer." alt="" coords="223,5,408,48"/>
<area shape="poly" title=" " alt="" coords="96,211,142,139,178,96,221,58,227,54,230,58,224,62,182,100,147,142,101,214"/>
<area shape="rect" href="classnz_1_1cu_strm_1_1_stream_manager.html#ab4b2eb422e0e1ee44bdfdc0eb94457ce" title="Returns a reference to the singleton instance of the StreamManager." alt="" coords="223,72,408,115"/>
<area shape="poly" title=" " alt="" coords="105,211,155,169,221,124,232,119,234,124,224,129,158,173,108,215"/>
<area shape="rect" href="classnz_1_1cu_strm_1_1_stream_manager.html#a97f78a2d43f6e0508c82d4f3b629de96" title="Asynchronously allocates device memory for type&#45;specific data with stream&#45;ordered dependency tracking..." alt="" coords="223,139,408,181"/>
<area shape="poly" title=" " alt="" coords="137,210,225,184,227,189,139,215"/>
<area shape="rect" href="classnz_1_1cu_strm_1_1_stream_manager.html#afa38d5c6db0e6b48c8f74ce8ad0df2bc" title="Asynchronously copies data between CUDA device and host memory based on the specified memory copy kin..." alt="" coords="223,272,408,315"/>
<area shape="poly" title=" " alt="" coords="139,238,227,264,225,270,137,243"/>
<area shape="rect" href="classnz_1_1cu_strm_1_1_stream_manager.html#a71ad766cb2869d3dd6a3931966e81706" title="Asynchronously sets a block of CUDA device memory to a specified value." alt="" coords="223,205,408,248"/>
<area shape="poly" title=" " alt="" coords="175,224,207,224,207,229,175,229"/>
<area shape="rect" href="classnz_1_1data_1_1_tensor.html#aade7b0c42622279888d755f4f7989aac" title="Retrieves the shape of the tensor." alt="" coords="236,339,394,365"/>
<area shape="poly" title=" " alt="" coords="107,238,157,281,189,304,224,324,238,331,236,335,221,329,186,309,153,285,104,242"/>
<area shape="rect" href="classnz_1_1data_1_1_tensor.html#a31a3aa01fa3ccb56503994a99e39e177" title="Retrieves the total number of elements in the tensor." alt="" coords="242,389,389,416"/>
<area shape="poly" title=" " alt="" coords="101,239,148,304,183,343,224,375,234,380,231,385,221,380,179,347,144,308,97,242"/>
<area shape="rect" href="classnz_1_1cu_strm_1_1_stream_manager.html#abe439fa00c0bd369c0b2345b095ed5af" title="Synchronizes host thread with completion events for a specific data object." alt="" coords="456,5,641,48"/>
<area shape="poly" title=" " alt="" coords="408,24,440,24,440,29,408,29"/>
<area shape="rect" href="classnz_1_1cu_strm_1_1_stream_manager.html#a1de1cf3aadea137faf90a2f9b4b7abe2" title="Acquires CUDA stream from pool using round&#45;robin scheduling." alt="" coords="456,205,641,248"/>
<area shape="poly" title=" " alt="" coords="393,179,457,198,456,203,391,184"/>
<area shape="poly" title=" " alt="" coords="391,269,456,250,457,255,393,274"/>
<area shape="rect" href="classnz_1_1cu_strm_1_1_stream_manager.html#adb1078a67c6e38932d7d58c2adb05ec0" title="Synchronizes CUDA stream execution until data writes complete." alt="" coords="456,272,641,315"/>
<area shape="poly" title=" " alt="" coords="408,291,440,291,440,296,408,296"/>
<area shape="poly" title=" " alt="" coords="408,224,440,224,440,229,408,229"/>
<area shape="poly" title=" " alt="" coords="393,246,457,265,456,270,391,251"/>
</map>
</div>

</div>
</div>
<a id="ae2cee8a54e65497113afd0c4f85dc02c" name="ae2cee8a54e65497113afd0c4f85dc02c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2cee8a54e65497113afd0c4f85dc02c">&#9670;&#160;</a></span>setData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nz::data::Tensor::setData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnz_1_1data_1_1_dimension.html">shape_type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>position</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">value_type</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a specific element of the tensor's data to a given value. </p>
<p>This function modifies a specific element of the tensor's data stored in GPU memory. The element to be modified is specified by its position in the tensor's shape (given as a 2D index). The function first copies the tensor's data from GPU memory to host memory, modifies the specified element, and then copies the updated data back to the GPU memory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>A <code>shape_type</code> (alias for <code>std::vector&lt;int&gt;</code>) representing the 2D index (row, column) of the element to modify. </td></tr>
    <tr><td class="paramname">value</td><td>The value to which the specified element will be set.</td></tr>
  </table>
  </dd>
</dl>
<p>This function performs the following steps:</p><ol type="1">
<li>It checks if the provided position is valid within the tensor's shape. If not, an exception is thrown.</li>
<li>It copies the tensor's data from GPU memory to host memory using <code>cudaMemcpy</code>.</li>
<li>It modifies the specified element at the given position in the tensor's data.</li>
<li>It copies the updated data back to the GPU memory.</li>
</ol>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>If the provided position is out of bounds.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>This function uses memory copying between host and device, which can introduce performance overhead.</li>
<li>The tensor's data is modified on the host first and then copied back to the GPU. This approach may not be the most efficient for large tensors or frequent updates.</li>
</ul>
</dd></dl>
<div class="fragment"><div class="line">```cpp</div>
<div class="line"><a class="code hl_class" href="classnz_1_1data_1_1_tensor.html">Tensor</a> tensor({2, 3});  <span class="comment">// Create a tensor with shape 2x3</span></div>
<div class="line">tensor.<a class="code hl_function" href="#ae2cee8a54e65497113afd0c4f85dc02c">setData</a>(std::vector&lt;int&gt;({1, 2}), 7.5f);  <span class="comment">// Set the element at position (1, 2) to 7.5f</span></div>
<div class="line">```</div>
<div class="ttc" id="aclassnz_1_1data_1_1_tensor_html_ae2cee8a54e65497113afd0c4f85dc02c"><div class="ttname"><a href="#ae2cee8a54e65497113afd0c4f85dc02c">nz::data::Tensor::setData</a></div><div class="ttdeci">void setData(const shape_type &amp;position, value_type value) const</div><div class="ttdoc">Sets a specific element of the tensor's data to a given value.</div><div class="ttdef"><b>Definition</b> <a href="_tensor_8cu_source.html#l00403">Tensor.cu:403</a></div></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="_tensor_8cu_source.html#l00403">403</a> of file <a class="el" href="_tensor_8cu_source.html">Tensor.cu</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classnz_1_1data_1_1_tensor_ae2cee8a54e65497113afd0c4f85dc02c_cgraph.png" border="0" usemap="#aclassnz_1_1data_1_1_tensor_ae2cee8a54e65497113afd0c4f85dc02c_cgraph" alt=""/></div>
<map name="aclassnz_1_1data_1_1_tensor_ae2cee8a54e65497113afd0c4f85dc02c_cgraph" id="aclassnz_1_1data_1_1_tensor_ae2cee8a54e65497113afd0c4f85dc02c_cgraph">
<area shape="rect" title="Sets a specific element of the tensor&#39;s data to a given value." alt="" coords="5,64,175,91"/>
<area shape="rect" href="classnz_1_1data_1_1_tensor.html#a38ba233ef49f34620297f96edd962c55" title="Retrieves a pointer to the tensor&#39;s data stored in GPU memory." alt="" coords="241,5,390,32"/>
<area shape="poly" title=" " alt="" coords="143,61,246,34,247,39,145,66"/>
<area shape="rect" href="classnz_1_1cu_strm_1_1_stream_manager.html#ab4b2eb422e0e1ee44bdfdc0eb94457ce" title="Returns a reference to the singleton instance of the StreamManager." alt="" coords="223,56,408,99"/>
<area shape="poly" title=" " alt="" coords="175,75,207,75,207,80,175,80"/>
<area shape="rect" href="classnz_1_1cu_strm_1_1_stream_manager.html#afa38d5c6db0e6b48c8f74ce8ad0df2bc" title="Asynchronously copies data between CUDA device and host memory based on the specified memory copy kin..." alt="" coords="223,123,408,165"/>
<area shape="poly" title=" " alt="" coords="139,89,227,115,225,120,137,94"/>
<area shape="rect" href="classnz_1_1cu_strm_1_1_stream_manager.html#a1de1cf3aadea137faf90a2f9b4b7abe2" title="Acquires CUDA stream from pool using round&#45;robin scheduling." alt="" coords="456,89,641,132"/>
<area shape="poly" title=" " alt="" coords="408,128,440,123,441,129,409,133"/>
<area shape="rect" href="classnz_1_1cu_strm_1_1_stream_manager.html#adb1078a67c6e38932d7d58c2adb05ec0" title="Synchronizes CUDA stream execution until data writes complete." alt="" coords="456,156,641,199"/>
<area shape="poly" title=" " alt="" coords="409,155,441,159,440,165,408,160"/>
</map>
</div>

</div>
</div>
<a id="abddb47a6dc305d289a1e4f91d01a5082" name="abddb47a6dc305d289a1e4f91d01a5082"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abddb47a6dc305d289a1e4f91d01a5082">&#9670;&#160;</a></span>setRequiresGrad()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nz::data::Tensor::setRequiresGrad </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>requires_grad</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets whether the tensor requires gradient computation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">requires_grad</td><td>A boolean indicating whether gradient computation is required.</td></tr>
  </table>
  </dd>
</dl>
<p>This function allows you to enable or disable gradient tracking for the tensor. If gradient computation is enabled, additional memory may be allocated for storing gradients.</p>
<dl class="section note"><dt>Note</dt><dd>Modifying this setting does not affect any existing gradient data stored in the tensor. </dd></dl>

<p class="definition">Definition at line <a class="el" href="_tensor_8cu_source.html#l00223">223</a> of file <a class="el" href="_tensor_8cu_source.html">Tensor.cu</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classnz_1_1data_1_1_tensor_abddb47a6dc305d289a1e4f91d01a5082_cgraph.png" border="0" usemap="#aclassnz_1_1data_1_1_tensor_abddb47a6dc305d289a1e4f91d01a5082_cgraph" alt=""/></div>
<map name="aclassnz_1_1data_1_1_tensor_abddb47a6dc305d289a1e4f91d01a5082_cgraph" id="aclassnz_1_1data_1_1_tensor_abddb47a6dc305d289a1e4f91d01a5082_cgraph">
<area shape="rect" title="Sets whether the tensor requires gradient computation." alt="" coords="5,80,227,107"/>
<area shape="rect" href="classnz_1_1cu_strm_1_1_stream_manager.html#a785cf34395067f425e032d9bd5e1fa20" title="Frees the CUDA device memory pointed to by the given pointer." alt="" coords="275,5,460,48"/>
<area shape="poly" title=" " alt="" coords="169,77,269,50,270,55,170,82"/>
<area shape="rect" href="classnz_1_1cu_strm_1_1_stream_manager.html#ab4b2eb422e0e1ee44bdfdc0eb94457ce" title="Returns a reference to the singleton instance of the StreamManager." alt="" coords="275,72,460,115"/>
<area shape="poly" title=" " alt="" coords="227,91,259,91,259,96,227,96"/>
<area shape="rect" href="classnz_1_1cu_strm_1_1_stream_manager.html#a97f78a2d43f6e0508c82d4f3b629de96" title="Asynchronously allocates device memory for type&#45;specific data with stream&#45;ordered dependency tracking..." alt="" coords="275,139,460,181"/>
<area shape="poly" title=" " alt="" coords="170,105,270,132,269,137,169,110"/>
<area shape="rect" href="classnz_1_1cu_strm_1_1_stream_manager.html#abe439fa00c0bd369c0b2345b095ed5af" title="Synchronizes host thread with completion events for a specific data object." alt="" coords="508,5,693,48"/>
<area shape="poly" title=" " alt="" coords="460,24,492,24,492,29,460,29"/>
<area shape="rect" href="classnz_1_1cu_strm_1_1_stream_manager.html#a1de1cf3aadea137faf90a2f9b4b7abe2" title="Acquires CUDA stream from pool using round&#45;robin scheduling." alt="" coords="508,139,693,181"/>
<area shape="poly" title=" " alt="" coords="460,157,492,157,492,163,460,163"/>
</map>
</div>

</div>
</div>
<a id="aade7b0c42622279888d755f4f7989aac" name="aade7b0c42622279888d755f4f7989aac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aade7b0c42622279888d755f4f7989aac">&#9670;&#160;</a></span>shape()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnz_1_1data_1_1_dimension.html">Tensor::shape_type</a> nz::data::Tensor::shape </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the shape of the tensor. </p>
<dl class="section return"><dt>Returns</dt><dd>A <code>shape_type</code> (alias for <code>std::vector&lt;int&gt;</code>) representing the dimensions of the tensor.</dd></dl>
<p>The shape provides information about the size of each dimension in the tensor. For example, a tensor with shape <code>{2, 3}</code> represents a 2x3 matrix. The shape is defined during construction or reshaping of the tensor. </p>

<p class="definition">Definition at line <a class="el" href="_tensor_8cu_source.html#l00219">219</a> of file <a class="el" href="_tensor_8cu_source.html">Tensor.cu</a>.</p>

</div>
</div>
<a id="a31a3aa01fa3ccb56503994a99e39e177" name="a31a3aa01fa3ccb56503994a99e39e177"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31a3aa01fa3ccb56503994a99e39e177">&#9670;&#160;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Tensor::size_type nz::data::Tensor::size </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the total number of elements in the tensor. </p>
<dl class="section return"><dt>Returns</dt><dd>A <code>size_type</code> (alias for <code>unsigned long long</code>) representing the total number of elements.</dd></dl>
<p>This function calculates the product of the dimensions in the tensor's shape. For example, a tensor with shape <code>{2, 3}</code> will have a size of 6. This value is useful for memory allocation and tensor operations. </p>

<p class="definition">Definition at line <a class="el" href="_tensor_8cu_source.html#l00220">220</a> of file <a class="el" href="_tensor_8cu_source.html">Tensor.cu</a>.</p>

</div>
</div>
<a id="a4a657091dfa6a490d873ab8e95d9bb9e" name="a4a657091dfa6a490d873ab8e95d9bb9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a657091dfa6a490d873ab8e95d9bb9e">&#9670;&#160;</a></span>sum() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Tensor::value_type nz::data::Tensor::sum </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the sum of all elements in the <a class="el" href="classnz_1_1data_1_1_tensor.html" title="A class for representing and manipulating multidimensional arrays (tensors) in GPU memory.">Tensor</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>The sum of all elements in the <a class="el" href="classnz_1_1data_1_1_tensor.html" title="A class for representing and manipulating multidimensional arrays (tensors) in GPU memory.">Tensor</a> as a value of type <code>Tensor::value_type</code>.</dd></dl>
<p>This function calculates the sum of all elements in the <a class="el" href="classnz_1_1data_1_1_tensor.html" title="A class for representing and manipulating multidimensional arrays (tensors) in GPU memory.">Tensor</a> using CUDA parallel processing. It first determines the block and grid dimensions for the CUDA kernel. Then, it allocates device memory for intermediate results and host memory to store the results copied from the device. The <code><a class="el" href="namespacenz_1_1krnl.html#a1ae846a65c2f5b83cd1b9fc61b877854" title="Kernel function to perform element-wise summation of two arrays.">krnl::Summation</a></code> CUDA kernel is launched to perform partial sums on the device. After the kernel execution, the partial sums are copied from the device to the host using <code>cudaMemcpy</code>. Finally, the partial sums on the host are added together to obtain the total sum, and the allocated host and device memory are freed.</p>
<p>Memory management:</p><ul>
<li>Host memory is allocated for <code>hData</code> using <code>new[]</code> and freed using <code>delete[]</code>.</li>
<li>Device memory is allocated for <code>dData</code> using <code>cudaMalloc</code> and freed using <code>cudaFree</code>.</li>
</ul>
<p>Exception handling:</p><ul>
<li>The <code>CHECK</code> macro is used to handle CUDA API errors. If a CUDA API call fails, the <code>CHECK</code> macro will throw an exception, and the function will terminate.</li>
</ul>
<p>Relationship with other components:</p><ul>
<li>This function depends on the <code><a class="el" href="namespacenz_1_1krnl.html#a1ae846a65c2f5b83cd1b9fc61b877854" title="Kernel function to perform element-wise summation of two arrays.">krnl::Summation</a></code> CUDA kernel to perform partial sums on the device.</li>
<li>It also depends on the <code>CHECK</code> macro to handle CUDA API errors.</li>
</ul>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">[Exception</td><td>type thrown by CHECK macro] If there are CUDA API errors during memory allocation, kernel execution, or memory copying.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>The time complexity of this function is approximately O(n), where n is the number of elements in the <a class="el" href="classnz_1_1data_1_1_tensor.html" title="A class for representing and manipulating multidimensional arrays (tensors) in GPU memory.">Tensor</a> (<code>_size</code>). The CUDA kernel parallelizes the partial sum calculation, and the final sum on the host is a linear operation over the number of grid blocks.</li>
<li>Ensure that the CUDA device is properly initialized before calling this function.</li>
</ul>
</dd></dl>
<div class="fragment"><div class="line">```cpp</div>
<div class="line"><a class="code hl_class" href="classnz_1_1data_1_1_tensor.html">nz::data::Tensor</a> tensor({2, 3}, <span class="keyword">true</span>);</div>
<div class="line"><span class="comment">// Assume tensor is filled with some values</span></div>
<div class="line">nz::data::Tensor::value_type sum_result = tensor.<a class="code hl_function" href="#a4a657091dfa6a490d873ab8e95d9bb9e">sum</a>();</div>
<div class="line">```</div>
<div class="ttc" id="aclassnz_1_1data_1_1_tensor_html_a4a657091dfa6a490d873ab8e95d9bb9e"><div class="ttname"><a href="#a4a657091dfa6a490d873ab8e95d9bb9e">nz::data::Tensor::sum</a></div><div class="ttdeci">value_type sum() const</div><div class="ttdoc">Compute the sum of all elements in the Tensor.</div><div class="ttdef"><b>Definition</b> <a href="_tensor_8cu_source.html#l00521">Tensor.cu:521</a></div></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="_tensor_8cu_source.html#l00521">521</a> of file <a class="el" href="_tensor_8cu_source.html">Tensor.cu</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classnz_1_1data_1_1_tensor_a4a657091dfa6a490d873ab8e95d9bb9e_cgraph.png" border="0" usemap="#aclassnz_1_1data_1_1_tensor_a4a657091dfa6a490d873ab8e95d9bb9e_cgraph" alt=""/></div>
<map name="aclassnz_1_1data_1_1_tensor_a4a657091dfa6a490d873ab8e95d9bb9e_cgraph" id="aclassnz_1_1data_1_1_tensor_a4a657091dfa6a490d873ab8e95d9bb9e_cgraph">
<area shape="rect" title="Compute the sum of all elements in the Tensor." alt="" coords="5,139,154,165"/>
<area shape="rect" href="classnz_1_1cu_strm_1_1_stream_manager.html#a785cf34395067f425e032d9bd5e1fa20" title="Frees the CUDA device memory pointed to by the given pointer." alt="" coords="202,12,387,55"/>
<area shape="poly" title=" " alt="" coords="101,136,200,76,232,60,235,64,203,81,104,140"/>
<area shape="rect" href="classnz_1_1cu_strm_1_1_stream_manager.html#ab4b2eb422e0e1ee44bdfdc0eb94457ce" title="Returns a reference to the singleton instance of the StreamManager." alt="" coords="435,72,620,115"/>
<area shape="poly" title=" " alt="" coords="140,136,201,124,314,109,419,99,420,104,314,115,202,129,141,141"/>
<area shape="rect" href="classnz_1_1cu_strm_1_1_stream_manager.html#a97f78a2d43f6e0508c82d4f3b629de96" title="Asynchronously allocates device memory for type&#45;specific data with stream&#45;ordered dependency tracking..." alt="" coords="202,252,387,295"/>
<area shape="poly" title=" " alt="" coords="104,164,203,223,238,242,235,247,200,228,101,168"/>
<area shape="rect" href="classnz_1_1cu_strm_1_1_stream_manager.html#afa38d5c6db0e6b48c8f74ce8ad0df2bc" title="Asynchronously copies data between CUDA device and host memory based on the specified memory copy kin..." alt="" coords="435,205,620,248"/>
<area shape="poly" title=" " alt="" coords="145,163,202,175,420,209,419,215,201,180,144,169"/>
<area shape="rect" href="namespacenz_1_1krnl.html#a1ae846a65c2f5b83cd1b9fc61b877854" title="Kernel function to perform element&#45;wise summation of two arrays." alt="" coords="225,139,364,165"/>
<area shape="poly" title=" " alt="" coords="154,149,210,149,210,155,154,155"/>
<area shape="rect" href="classnz_1_1cu_strm_1_1_stream_manager.html#abe439fa00c0bd369c0b2345b095ed5af" title="Synchronizes host thread with completion events for a specific data object." alt="" coords="435,5,620,48"/>
<area shape="poly" title=" " alt="" coords="387,28,419,27,420,32,388,33"/>
<area shape="rect" href="classnz_1_1cu_strm_1_1_stream_manager.html#a1de1cf3aadea137faf90a2f9b4b7abe2" title="Acquires CUDA stream from pool using round&#45;robin scheduling." alt="" coords="668,205,854,248"/>
<area shape="poly" title=" " alt="" coords="387,272,499,268,620,257,664,249,665,255,621,263,499,274,387,277"/>
<area shape="poly" title=" " alt="" coords="621,224,653,224,653,229,621,229"/>
<area shape="rect" href="classnz_1_1cu_strm_1_1_stream_manager.html#adb1078a67c6e38932d7d58c2adb05ec0" title="Synchronizes CUDA stream execution until data writes complete." alt="" coords="668,139,854,181"/>
<area shape="poly" title=" " alt="" coords="604,202,668,184,670,189,605,207"/>
<area shape="poly" title=" " alt="" coords="350,136,425,116,426,122,351,141"/>
<area shape="rect" href="classnz_1_1cu_strm_1_1_stream_manager.html#a46ce59b45de432842454aadf00b93791" title="Asynchronously submits a CUDA kernel with stream&#45;ordered dependency management." alt="" coords="435,139,620,181"/>
<area shape="poly" title=" " alt="" coords="364,152,419,154,419,159,364,157"/>
<area shape="poly" title=" " alt="" coords="605,179,670,198,668,203,604,184"/>
<area shape="poly" title=" " alt="" coords="621,157,653,157,653,163,621,163"/>
</map>
</div>

</div>
</div>
<a id="a74aa515ba6b83aa1d05a7bb001b297b3" name="a74aa515ba6b83aa1d05a7bb001b297b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74aa515ba6b83aa1d05a7bb001b297b3">&#9670;&#160;</a></span>sum() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Tensor::value_type nz::data::Tensor::sum </td>
          <td>(</td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>batch</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>channel</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the sum of elements in a specific batch and channel of a <a class="el" href="classnz_1_1data_1_1_tensor.html" title="A class for representing and manipulating multidimensional arrays (tensors) in GPU memory.">Tensor</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">batch</td><td>The batch index. This value should be within the valid range of the <a class="el" href="classnz_1_1data_1_1_tensor.html" title="A class for representing and manipulating multidimensional arrays (tensors) in GPU memory.">Tensor</a>'s batch dimension. Memory flow: host - to - device (used for index calculation on the host side). </td></tr>
    <tr><td class="paramname">channel</td><td>The channel index. This value should be within the valid range of the <a class="el" href="classnz_1_1data_1_1_tensor.html" title="A class for representing and manipulating multidimensional arrays (tensors) in GPU memory.">Tensor</a>'s channel dimension. Memory flow: host - to - device (used for index calculation on the host side).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sum of elements in the specified batch and channel of the <a class="el" href="classnz_1_1data_1_1_tensor.html" title="A class for representing and manipulating multidimensional arrays (tensors) in GPU memory.">Tensor</a>.</dd></dl>
<p>This function calculates the sum of elements in a particular batch and channel of a <a class="el" href="classnz_1_1data_1_1_tensor.html" title="A class for representing and manipulating multidimensional arrays (tensors) in GPU memory.">Tensor</a>. First, it checks if the provided <code>batch</code> and <code>channel</code> indices are valid. If not, it throws a <code>std::invalid_argument</code> exception. Then, it calculates the size of the region to be summed based on the <a class="el" href="classnz_1_1data_1_1_tensor.html" title="A class for representing and manipulating multidimensional arrays (tensors) in GPU memory.">Tensor</a>'s shape. It allocates device memory for intermediate results and host memory to receive the intermediate results from the device. It determines the offset in the <a class="el" href="classnz_1_1data_1_1_tensor.html" title="A class for representing and manipulating multidimensional arrays (tensors) in GPU memory.">Tensor</a>'s data based on the <code>batch</code> and <code>channel</code> indices. The <code><a class="el" href="namespacenz_1_1krnl.html#a1ae846a65c2f5b83cd1b9fc61b877854" title="Kernel function to perform element-wise summation of two arrays.">krnl::Summation</a></code> kernel is then launched to perform the partial summation on the device. After that, the intermediate results are copied from the device to the host. Finally, the function sums up all the intermediate results on the host, frees the allocated host and device memory, and returns the final sum.</p>
<p><b>Memory Management Strategy</b>:</p><ul>
<li>On the host side, an array <code>hData</code> of size <code>grid.x</code> is dynamically allocated using <code>new[]</code> and later freed using <code>delete[]</code>.</li>
<li>On the device side, memory for <code>dData</code> is allocated using <code><a class="el" href="classnz_1_1cu_strm_1_1_stream_manager.html" title="Centralized CUDA stream and resource management system with automatic dependency tracking.">cuStrm::StreamManager</a>&lt;value_type&gt;::Instance().malloc</code> and freed using <code><a class="el" href="classnz_1_1cu_strm_1_1_stream_manager.html" title="Centralized CUDA stream and resource management system with automatic dependency tracking.">cuStrm::StreamManager</a>&lt;value_type&gt;::Instance().free</code>.</li>
</ul>
<p><b>Exception Handling Mechanism</b>:</p><ul>
<li>Throws a <code>std::invalid_argument</code> exception if the provided <code>batch</code> or <code>channel</code> indices are out of the valid range of the <a class="el" href="classnz_1_1data_1_1_tensor.html" title="A class for representing and manipulating multidimensional arrays (tensors) in GPU memory.">Tensor</a>'s shape.</li>
<li>The CUDA memory allocation, copying, and kernel launch operations may return error codes indicating failures. It is assumed that the calling code or the CUDA runtime will handle these errors appropriately.</li>
</ul>
<p><b>Relationship with Other Components</b>:</p><ul>
<li>Depends on the <code>_shape</code> member of the <code><a class="el" href="classnz_1_1data_1_1_tensor.html" title="A class for representing and manipulating multidimensional arrays (tensors) in GPU memory.">Tensor</a></code> class to get the shape information and strides.</li>
<li>Uses the <code><a class="el" href="namespacenz_1_1krnl.html#a1ae846a65c2f5b83cd1b9fc61b877854" title="Kernel function to perform element-wise summation of two arrays.">krnl::Summation</a></code> kernel to perform the partial summation on the device.</li>
<li>Relies on <code><a class="el" href="classnz_1_1cu_strm_1_1_stream_manager.html" title="Centralized CUDA stream and resource management system with automatic dependency tracking.">cuStrm::StreamManager</a>&lt;value_type&gt;::Instance()</code> for CUDA memory management (malloc, memcpy, free) operations.</li>
</ul>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>If the provided <code>batch</code> or <code>channel</code> indices are out of the valid range of the <a class="el" href="classnz_1_1data_1_1_tensor.html" title="A class for representing and manipulating multidimensional arrays (tensors) in GPU memory.">Tensor</a>'s shape.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>Ensure that the provided <code>batch</code> and <code>channel</code> indices are within the valid range of the <a class="el" href="classnz_1_1data_1_1_tensor.html" title="A class for representing and manipulating multidimensional arrays (tensors) in GPU memory.">Tensor</a>'s shape to avoid exceptions.</li>
<li>The CUDA operations such as memory allocation, copying, and kernel launch have their own error handling mechanisms. The calling code should be prepared to handle potential CUDA errors.</li>
</ul>
</dd></dl>
<div class="fragment"><div class="line">```cpp</div>
<div class="line"><a class="code hl_class" href="classnz_1_1data_1_1_tensor.html">Tensor</a> tensor; <span class="comment">// Assume Tensor is properly initialized</span></div>
<div class="line">Tensor::size_type batch = 0;</div>
<div class="line">Tensor::size_type channel = 1;</div>
<div class="line">Tensor::value_type sumResult = tensor.<a class="code hl_function" href="#a4a657091dfa6a490d873ab8e95d9bb9e">sum</a>(batch, channel);</div>
<div class="line">```</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="_tensor_8cu_source.html#l00539">539</a> of file <a class="el" href="_tensor_8cu_source.html">Tensor.cu</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classnz_1_1data_1_1_tensor_a74aa515ba6b83aa1d05a7bb001b297b3_cgraph.png" border="0" usemap="#aclassnz_1_1data_1_1_tensor_a74aa515ba6b83aa1d05a7bb001b297b3_cgraph" alt=""/></div>
<map name="aclassnz_1_1data_1_1_tensor_a74aa515ba6b83aa1d05a7bb001b297b3_cgraph" id="aclassnz_1_1data_1_1_tensor_a74aa515ba6b83aa1d05a7bb001b297b3_cgraph">
<area shape="rect" title="Computes the sum of elements in a specific batch and channel of a Tensor." alt="" coords="5,164,154,191"/>
<area shape="rect" href="classnz_1_1cu_strm_1_1_stream_manager.html#a785cf34395067f425e032d9bd5e1fa20" title="Frees the CUDA device memory pointed to by the given pointer." alt="" coords="202,5,387,48"/>
<area shape="poly" title=" " alt="" coords="90,162,135,112,166,83,200,58,208,53,211,58,203,62,169,87,138,116,94,165"/>
<area shape="rect" href="classnz_1_1cu_strm_1_1_stream_manager.html#ab4b2eb422e0e1ee44bdfdc0eb94457ce" title="Returns a reference to the singleton instance of the StreamManager." alt="" coords="435,131,620,173"/>
<area shape="poly" title=" " alt="" coords="154,171,420,155,420,161,154,176"/>
<area shape="rect" href="classnz_1_1cu_strm_1_1_stream_manager.html#a97f78a2d43f6e0508c82d4f3b629de96" title="Asynchronously allocates device memory for type&#45;specific data with stream&#45;ordered dependency tracking..." alt="" coords="202,72,387,115"/>
<area shape="poly" title=" " alt="" coords="115,161,223,118,225,123,117,166"/>
<area shape="rect" href="classnz_1_1cu_strm_1_1_stream_manager.html#afa38d5c6db0e6b48c8f74ce8ad0df2bc" title="Asynchronously copies data between CUDA device and host memory based on the specified memory copy kin..." alt="" coords="435,264,620,307"/>
<area shape="poly" title=" " alt="" coords="94,189,138,235,168,258,203,276,256,291,312,299,367,300,419,298,419,303,368,306,312,304,255,296,201,281,165,263,134,239,90,193"/>
<area shape="rect" href="classnz_1_1data_1_1_tensor.html#a31a3aa01fa3ccb56503994a99e39e177" title="Retrieves the total number of elements in the tensor." alt="" coords="221,240,368,267"/>
<area shape="poly" title=" " alt="" coords="112,189,203,225,225,233,223,238,201,231,110,194"/>
<area shape="rect" href="namespacenz_1_1krnl.html#a1ae846a65c2f5b83cd1b9fc61b877854" title="Kernel function to perform element&#45;wise summation of two arrays." alt="" coords="225,189,364,216"/>
<area shape="poly" title=" " alt="" coords="154,183,210,190,209,195,154,189"/>
<area shape="rect" href="classnz_1_1cu_strm_1_1_stream_manager.html#abe439fa00c0bd369c0b2345b095ed5af" title="Synchronizes host thread with completion events for a specific data object." alt="" coords="435,5,620,48"/>
<area shape="poly" title=" " alt="" coords="387,24,419,24,419,29,387,29"/>
<area shape="rect" href="classnz_1_1cu_strm_1_1_stream_manager.html#a1de1cf3aadea137faf90a2f9b4b7abe2" title="Acquires CUDA stream from pool using round&#45;robin scheduling." alt="" coords="668,197,854,240"/>
<area shape="poly" title=" " alt="" coords="387,85,441,85,501,90,562,99,621,116,652,130,680,147,728,185,725,189,677,152,649,135,619,121,561,105,500,95,441,91,387,90"/>
<area shape="poly" title=" " alt="" coords="604,261,668,242,670,247,605,266"/>
<area shape="rect" href="classnz_1_1cu_strm_1_1_stream_manager.html#adb1078a67c6e38932d7d58c2adb05ec0" title="Synchronizes CUDA stream execution until data writes complete." alt="" coords="668,264,854,307"/>
<area shape="poly" title=" " alt="" coords="621,283,653,283,653,288,621,288"/>
<area shape="poly" title=" " alt="" coords="359,186,419,173,420,178,360,191"/>
<area shape="rect" href="classnz_1_1cu_strm_1_1_stream_manager.html#a46ce59b45de432842454aadf00b93791" title="Asynchronously submits a CUDA kernel with stream&#45;ordered dependency management." alt="" coords="435,197,620,240"/>
<area shape="poly" title=" " alt="" coords="364,205,420,209,419,214,363,210"/>
<area shape="poly" title=" " alt="" coords="621,216,653,216,653,221,621,221"/>
<area shape="poly" title=" " alt="" coords="605,238,670,257,668,262,604,243"/>
</map>
</div>

</div>
</div>
<a id="a0c150b841f02921eb7826a6e03d0267e" name="a0c150b841f02921eb7826a6e03d0267e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c150b841f02921eb7826a6e03d0267e">&#9670;&#160;</a></span>sync()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nz::data::Tensor::sync </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synchronize both the tensor data and its gradient data. </p>
<p>This function calls the <code>syncData</code> method to synchronize the tensor data and then calls the <code>syncGrad</code> method to synchronize the gradient data if gradient computation is required. It ensures that all CUDA stream write operations on the data and gradient (if applicable) are completed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<p>Memory management for the data and gradient is assumed to be handled by the <code>syncData</code> and <code>syncGrad</code> methods respectively. There is no additional memory allocation or deallocation within this function. This function does not have an explicit exception - handling mechanism. It relies on the exception - handling of the <code>syncData</code> and <code>syncGrad</code> methods to manage any errors that may occur during the synchronization process.</p>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>The time complexity of this function depends on the time complexity of the <code>syncData</code> and <code>syncGrad</code> methods. In the worst - case scenario, if both operations involve long - running CUDA stream write operations, it may take a significant amount of time.</li>
</ul>
</dd></dl>
<div class="fragment"><div class="line">```cpp</div>
<div class="line"><span class="comment">// Assume Tensor is defined and an instance is created</span></div>
<div class="line"><a class="code hl_class" href="classnz_1_1data_1_1_tensor.html">Tensor</a> tensor;</div>
<div class="line">tensor.<a class="code hl_function" href="#a0c150b841f02921eb7826a6e03d0267e">sync</a>();</div>
<div class="line">```</div>
<div class="ttc" id="aclassnz_1_1data_1_1_tensor_html_a0c150b841f02921eb7826a6e03d0267e"><div class="ttname"><a href="#a0c150b841f02921eb7826a6e03d0267e">nz::data::Tensor::sync</a></div><div class="ttdeci">void sync() const</div><div class="ttdoc">Synchronize both the tensor data and its gradient data.</div><div class="ttdef"><b>Definition</b> <a href="_tensor_8cu_source.html#l00613">Tensor.cu:613</a></div></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="_tensor_8cu_source.html#l00613">613</a> of file <a class="el" href="_tensor_8cu_source.html">Tensor.cu</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classnz_1_1data_1_1_tensor_a0c150b841f02921eb7826a6e03d0267e_cgraph.png" border="0" usemap="#aclassnz_1_1data_1_1_tensor_a0c150b841f02921eb7826a6e03d0267e_cgraph" alt=""/></div>
<map name="aclassnz_1_1data_1_1_tensor_a0c150b841f02921eb7826a6e03d0267e_cgraph" id="aclassnz_1_1data_1_1_tensor_a0c150b841f02921eb7826a6e03d0267e_cgraph">
<area shape="rect" title="Synchronize both the tensor data and its gradient data." alt="" coords="5,47,157,73"/>
<area shape="rect" href="classnz_1_1data_1_1_tensor.html#a7aab89d371ff013c5c021a191bd7348e" title="Synchronize the tensor data by waiting for all CUDA stream write operations to complete." alt="" coords="205,21,384,48"/>
<area shape="poly" title=" " alt="" coords="157,48,189,45,189,50,158,54"/>
<area shape="rect" href="classnz_1_1data_1_1_tensor.html#af28425ddc9bee1f75fd923a0de68c37b" title="Synchronize the gradient data of the tensor if gradient computation is required." alt="" coords="205,72,384,99"/>
<area shape="poly" title=" " alt="" coords="158,66,189,70,189,75,157,72"/>
<area shape="rect" href="classnz_1_1cu_strm_1_1_stream_manager.html#ab4b2eb422e0e1ee44bdfdc0eb94457ce" title="Returns a reference to the singleton instance of the StreamManager." alt="" coords="432,5,617,48"/>
<area shape="poly" title=" " alt="" coords="384,29,416,28,417,33,384,34"/>
<area shape="rect" href="classnz_1_1cu_strm_1_1_stream_manager.html#abe439fa00c0bd369c0b2345b095ed5af" title="Synchronizes host thread with completion events for a specific data object." alt="" coords="432,72,617,115"/>
<area shape="poly" title=" " alt="" coords="350,46,424,65,423,70,349,51"/>
<area shape="poly" title=" " alt="" coords="349,69,423,50,424,55,350,74"/>
<area shape="poly" title=" " alt="" coords="384,86,417,87,416,92,384,91"/>
</map>
</div>

</div>
</div>
<a id="a7aab89d371ff013c5c021a191bd7348e" name="a7aab89d371ff013c5c021a191bd7348e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7aab89d371ff013c5c021a191bd7348e">&#9670;&#160;</a></span>syncData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nz::data::Tensor::syncData </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synchronize the tensor data by waiting for all CUDA stream write operations to complete. </p>
<p>This function accesses the singleton instance of <code><a class="el" href="classnz_1_1cu_strm_1_1_stream_manager.html" title="Centralized CUDA stream and resource management system with automatic dependency tracking.">cuStrm::StreamManager</a></code> specialized for the <code>value_type</code> of the <code><a class="el" href="classnz_1_1data_1_1_tensor.html" title="A class for representing and manipulating multidimensional arrays (tensors) in GPU memory.">Tensor</a></code> class. It then calls the <code>syncData</code> method of this instance, passing the <code>_data</code> member of the <code><a class="el" href="classnz_1_1data_1_1_tensor.html" title="A class for representing and manipulating multidimensional arrays (tensors) in GPU memory.">Tensor</a></code> object. This operation blocks the host until all CUDA stream write operations on the <code>_data</code> are finished.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<p>Memory management for the <code>_data</code> is assumed to be handled elsewhere in the codebase. There is no memory allocation or deallocation within this function. This function does not have an explicit exception - handling mechanism. It relies on the <code>syncData</code> method of the <code><a class="el" href="classnz_1_1cu_strm_1_1_stream_manager.html" title="Centralized CUDA stream and resource management system with automatic dependency tracking.">cuStrm::StreamManager</a></code> instance to manage any errors that may occur during the synchronization process.</p>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>The time complexity of this function depends on the time required for the CUDA stream write operations on <code>_data</code> to complete. In the worst - case scenario, if there are long - running write operations, it may take a significant amount of time.</li>
</ul>
</dd></dl>
<div class="fragment"><div class="line">```cpp</div>
<div class="line"><span class="comment">// Assume Tensor is defined and an instance is created</span></div>
<div class="line"><a class="code hl_class" href="classnz_1_1data_1_1_tensor.html">Tensor</a> tensor;</div>
<div class="line">tensor.<a class="code hl_function" href="#a7aab89d371ff013c5c021a191bd7348e">syncData</a>();</div>
<div class="line">```</div>
<div class="ttc" id="aclassnz_1_1data_1_1_tensor_html_a7aab89d371ff013c5c021a191bd7348e"><div class="ttname"><a href="#a7aab89d371ff013c5c021a191bd7348e">nz::data::Tensor::syncData</a></div><div class="ttdeci">void syncData() const</div><div class="ttdoc">Synchronize the tensor data by waiting for all CUDA stream write operations to complete.</div><div class="ttdef"><b>Definition</b> <a href="_tensor_8cu_source.html#l00603">Tensor.cu:603</a></div></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="_tensor_8cu_source.html#l00603">603</a> of file <a class="el" href="_tensor_8cu_source.html">Tensor.cu</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classnz_1_1data_1_1_tensor_a7aab89d371ff013c5c021a191bd7348e_cgraph.png" border="0" usemap="#aclassnz_1_1data_1_1_tensor_a7aab89d371ff013c5c021a191bd7348e_cgraph" alt=""/></div>
<map name="aclassnz_1_1data_1_1_tensor_a7aab89d371ff013c5c021a191bd7348e_cgraph" id="aclassnz_1_1data_1_1_tensor_a7aab89d371ff013c5c021a191bd7348e_cgraph">
<area shape="rect" title="Synchronize the tensor data by waiting for all CUDA stream write operations to complete." alt="" coords="5,47,185,73"/>
<area shape="rect" href="classnz_1_1cu_strm_1_1_stream_manager.html#ab4b2eb422e0e1ee44bdfdc0eb94457ce" title="Returns a reference to the singleton instance of the StreamManager." alt="" coords="233,5,418,48"/>
<area shape="poly" title=" " alt="" coords="185,44,217,40,217,45,185,50"/>
<area shape="rect" href="classnz_1_1cu_strm_1_1_stream_manager.html#abe439fa00c0bd369c0b2345b095ed5af" title="Synchronizes host thread with completion events for a specific data object." alt="" coords="233,72,418,115"/>
<area shape="poly" title=" " alt="" coords="185,70,217,75,217,80,185,76"/>
</map>
</div>

</div>
</div>
<a id="af28425ddc9bee1f75fd923a0de68c37b" name="af28425ddc9bee1f75fd923a0de68c37b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af28425ddc9bee1f75fd923a0de68c37b">&#9670;&#160;</a></span>syncGrad()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nz::data::Tensor::syncGrad </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synchronize the gradient data of the tensor if gradient computation is required. </p>
<p>This function first checks the <code>_requires_grad</code> flag of the <code><a class="el" href="classnz_1_1data_1_1_tensor.html" title="A class for representing and manipulating multidimensional arrays (tensors) in GPU memory.">Tensor</a></code> object. If the flag is set to <code>true</code>, it accesses the singleton instance of <code><a class="el" href="classnz_1_1cu_strm_1_1_stream_manager.html" title="Centralized CUDA stream and resource management system with automatic dependency tracking.">cuStrm::StreamManager</a></code> specialized for the <code>value_type</code> of the <code><a class="el" href="classnz_1_1data_1_1_tensor.html" title="A class for representing and manipulating multidimensional arrays (tensors) in GPU memory.">Tensor</a></code> class. Then it calls the <code>syncData</code> method of this instance, passing the <code>_grad</code> member of the <code><a class="el" href="classnz_1_1data_1_1_tensor.html" title="A class for representing and manipulating multidimensional arrays (tensors) in GPU memory.">Tensor</a></code> object. This operation blocks the host until all CUDA stream write operations on the <code>_grad</code> are completed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<p>Memory management for the <code>_grad</code> is assumed to be handled elsewhere in the codebase. There is no memory allocation or deallocation within this function. This function does not have an explicit exception - handling mechanism. It relies on the <code>syncData</code> method of the <code><a class="el" href="classnz_1_1cu_strm_1_1_stream_manager.html" title="Centralized CUDA stream and resource management system with automatic dependency tracking.">cuStrm::StreamManager</a></code> instance to manage any errors that may occur during the synchronization process.</p>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>The time complexity of this function depends on whether the <code>_requires_grad</code> flag is <code>true</code> and the time required for the CUDA stream write operations on <code>_grad</code> to complete. If <code>_requires_grad</code> is <code>false</code>, the function has a constant time complexity O(1). Otherwise, in the worst - case scenario with long - running write operations, it may take a significant amount of time.</li>
</ul>
</dd></dl>
<div class="fragment"><div class="line">```cpp</div>
<div class="line"><span class="comment">// Assume Tensor is defined and an instance is created</span></div>
<div class="line"><a class="code hl_class" href="classnz_1_1data_1_1_tensor.html">Tensor</a> tensor;</div>
<div class="line">tensor.<a class="code hl_function" href="#af28425ddc9bee1f75fd923a0de68c37b">syncGrad</a>();</div>
<div class="line">```</div>
<div class="ttc" id="aclassnz_1_1data_1_1_tensor_html_af28425ddc9bee1f75fd923a0de68c37b"><div class="ttname"><a href="#af28425ddc9bee1f75fd923a0de68c37b">nz::data::Tensor::syncGrad</a></div><div class="ttdeci">void syncGrad() const</div><div class="ttdoc">Synchronize the gradient data of the tensor if gradient computation is required.</div><div class="ttdef"><b>Definition</b> <a href="_tensor_8cu_source.html#l00607">Tensor.cu:607</a></div></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="_tensor_8cu_source.html#l00607">607</a> of file <a class="el" href="_tensor_8cu_source.html">Tensor.cu</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classnz_1_1data_1_1_tensor_af28425ddc9bee1f75fd923a0de68c37b_cgraph.png" border="0" usemap="#aclassnz_1_1data_1_1_tensor_af28425ddc9bee1f75fd923a0de68c37b_cgraph" alt=""/></div>
<map name="aclassnz_1_1data_1_1_tensor_af28425ddc9bee1f75fd923a0de68c37b_cgraph" id="aclassnz_1_1data_1_1_tensor_af28425ddc9bee1f75fd923a0de68c37b_cgraph">
<area shape="rect" title="Synchronize the gradient data of the tensor if gradient computation is required." alt="" coords="5,47,185,73"/>
<area shape="rect" href="classnz_1_1cu_strm_1_1_stream_manager.html#ab4b2eb422e0e1ee44bdfdc0eb94457ce" title="Returns a reference to the singleton instance of the StreamManager." alt="" coords="233,5,418,48"/>
<area shape="poly" title=" " alt="" coords="185,44,217,40,217,45,185,50"/>
<area shape="rect" href="classnz_1_1cu_strm_1_1_stream_manager.html#abe439fa00c0bd369c0b2345b095ed5af" title="Synchronizes host thread with completion events for a specific data object." alt="" coords="233,72,418,115"/>
<area shape="poly" title=" " alt="" coords="185,70,217,75,217,80,185,76"/>
</map>
</div>

</div>
</div>
<a id="a45e6f84ae74111ced9a96bdf204b2294" name="a45e6f84ae74111ced9a96bdf204b2294"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45e6f84ae74111ced9a96bdf204b2294">&#9670;&#160;</a></span>transpose()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nz::data::Tensor::transpose </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transposes the tensor by swapping its dimensions and rearranging the data. </p>
<p>This function performs a transpose on the tensor by swapping its rows and columns. For a 2D tensor (matrix), it swaps the first and second dimensions, effectively turning the rows into columns and vice versa. The tensor's data is rearranged using a temporary buffer, and the shape is updated accordingly. The data is first copied to a temporary memory space, then a CUDA kernel is used to perform the transposition.</p>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>This function involves memory allocation and data copying. It creates a temporary tensor in GPU memory to hold the transposed data.</li>
<li>After the transposition, the tensor's shape is updated, and the temporary buffer is freed.</li>
<li>The function does not modify the original tensor's data but instead reinterprets the data with the new shape.</li>
</ul>
</dd></dl>
<div class="fragment"><div class="line">```cpp</div>
<div class="line"><a class="code hl_class" href="classnz_1_1data_1_1_tensor.html">Tensor</a> tensor({2, 3});  <span class="comment">// Create a tensor with shape 2x3</span></div>
<div class="line">tensor.<a class="code hl_function" href="#a45e6f84ae74111ced9a96bdf204b2294">transpose</a>();     <span class="comment">// Transpose the tensor to shape 3x2</span></div>
<div class="line">```</div>
<div class="ttc" id="aclassnz_1_1data_1_1_tensor_html_a45e6f84ae74111ced9a96bdf204b2294"><div class="ttname"><a href="#a45e6f84ae74111ced9a96bdf204b2294">nz::data::Tensor::transpose</a></div><div class="ttdeci">void transpose()</div><div class="ttdoc">Transposes the tensor by swapping its dimensions and rearranging the data.</div><div class="ttdef"><b>Definition</b> <a href="_tensor_8cu_source.html#l00378">Tensor.cu:378</a></div></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="_tensor_8cu_source.html#l00378">378</a> of file <a class="el" href="_tensor_8cu_source.html">Tensor.cu</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classnz_1_1data_1_1_tensor_a45e6f84ae74111ced9a96bdf204b2294_cgraph.png" border="0" usemap="#aclassnz_1_1data_1_1_tensor_a45e6f84ae74111ced9a96bdf204b2294_cgraph" alt=""/></div>
<map name="aclassnz_1_1data_1_1_tensor_a45e6f84ae74111ced9a96bdf204b2294_cgraph" id="aclassnz_1_1data_1_1_tensor_a45e6f84ae74111ced9a96bdf204b2294_cgraph">
<area shape="rect" title="Transposes the tensor by swapping its dimensions and rearranging the data." alt="" coords="5,84,186,111"/>
<area shape="rect" href="classnz_1_1cu_strm_1_1_stream_manager.html#a1084057ef6f5b2871c60702209bb4469" title="Asynchronously frees the CUDA device memory pointed to by the given pointer." alt="" coords="415,5,600,48"/>
<area shape="poly" title=" " alt="" coords="171,81,233,69,400,41,401,46,234,75,171,86"/>
<area shape="rect" href="classnz_1_1cu_strm_1_1_stream_manager.html#ab4b2eb422e0e1ee44bdfdc0eb94457ce" title="Returns a reference to the singleton instance of the StreamManager." alt="" coords="415,139,600,181"/>
<area shape="poly" title=" " alt="" coords="169,109,234,120,400,144,400,149,233,125,168,114"/>
<area shape="rect" href="namespacenz_1_1krnl.html#afe3f38f788c735b7eb718443eb0fd094" title="Kernel function to transpose a matrix on the GPU." alt="" coords="234,84,367,111"/>
<area shape="poly" title=" " alt="" coords="186,95,218,95,218,100,186,100"/>
<area shape="rect" href="classnz_1_1cu_strm_1_1_stream_manager.html#a1de1cf3aadea137faf90a2f9b4b7abe2" title="Acquires CUDA stream from pool using round&#45;robin scheduling." alt="" coords="648,72,834,115"/>
<area shape="poly" title=" " alt="" coords="585,46,650,65,648,70,584,51"/>
<area shape="rect" href="classnz_1_1cu_strm_1_1_stream_manager.html#adb1078a67c6e38932d7d58c2adb05ec0" title="Synchronizes CUDA stream execution until data writes complete." alt="" coords="648,5,834,48"/>
<area shape="poly" title=" " alt="" coords="601,24,633,24,633,29,601,29"/>
<area shape="poly" title=" " alt="" coords="348,109,421,131,419,136,346,114"/>
<area shape="rect" href="classnz_1_1cu_strm_1_1_stream_manager.html#a46ce59b45de432842454aadf00b93791" title="Asynchronously submits a CUDA kernel with stream&#45;ordered dependency management." alt="" coords="415,72,600,115"/>
<area shape="poly" title=" " alt="" coords="367,93,399,93,399,98,368,99"/>
<area shape="poly" title=" " alt="" coords="601,91,633,91,633,96,601,96"/>
<area shape="poly" title=" " alt="" coords="584,69,648,50,650,55,585,74"/>
</map>
</div>

</div>
</div>
<a id="a6fed8efad540a7621dd6640b2f2466d0" name="a6fed8efad540a7621dd6640b2f2466d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fed8efad540a7621dd6640b2f2466d0">&#9670;&#160;</a></span>zeroGrad()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nz::data::Tensor::zeroGrad </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resets the gradient data to zero. </p>
<p>This function sets the gradient data of the tensor to zero. It is typically used during training in neural networks to clear the gradients before the next backpropagation pass. The gradient memory will remain allocated, but its contents will be zeroed out.</p>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>This function does not deallocate the gradient memory; it only resets the stored gradient values.</li>
<li>The tensor must have been created with <code>requires_grad</code> set to <code>true</code>, otherwise the function does nothing.</li>
</ul>
</dd></dl>
<div class="fragment"><div class="line">```cpp</div>
<div class="line"><a class="code hl_class" href="classnz_1_1data_1_1_tensor.html">Tensor</a> tensor({2, 3}, <span class="keyword">true</span>);  <span class="comment">// Create a tensor with gradient support</span></div>
<div class="line">tensor.<a class="code hl_function" href="#a6fed8efad540a7621dd6640b2f2466d0">zeroGrad</a>();  <span class="comment">// Reset the gradients to zero</span></div>
<div class="line">```</div>
<div class="ttc" id="aclassnz_1_1data_1_1_tensor_html_a6fed8efad540a7621dd6640b2f2466d0"><div class="ttname"><a href="#a6fed8efad540a7621dd6640b2f2466d0">nz::data::Tensor::zeroGrad</a></div><div class="ttdeci">void zeroGrad() const</div><div class="ttdoc">Resets the gradient data to zero.</div><div class="ttdef"><b>Definition</b> <a href="_tensor_8cu_source.html#l00240">Tensor.cu:240</a></div></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="_tensor_8cu_source.html#l00240">240</a> of file <a class="el" href="_tensor_8cu_source.html">Tensor.cu</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classnz_1_1data_1_1_tensor_a6fed8efad540a7621dd6640b2f2466d0_cgraph.png" border="0" usemap="#aclassnz_1_1data_1_1_tensor_a6fed8efad540a7621dd6640b2f2466d0_cgraph" alt=""/></div>
<map name="aclassnz_1_1data_1_1_tensor_a6fed8efad540a7621dd6640b2f2466d0_cgraph" id="aclassnz_1_1data_1_1_tensor_a6fed8efad540a7621dd6640b2f2466d0_cgraph">
<area shape="rect" title="Resets the gradient data to zero." alt="" coords="5,47,182,73"/>
<area shape="rect" href="classnz_1_1cu_strm_1_1_stream_manager.html#ab4b2eb422e0e1ee44bdfdc0eb94457ce" title="Returns a reference to the singleton instance of the StreamManager." alt="" coords="230,5,415,48"/>
<area shape="poly" title=" " alt="" coords="182,44,214,40,215,45,183,50"/>
<area shape="rect" href="classnz_1_1cu_strm_1_1_stream_manager.html#a71ad766cb2869d3dd6a3931966e81706" title="Asynchronously sets a block of CUDA device memory to a specified value." alt="" coords="230,72,415,115"/>
<area shape="poly" title=" " alt="" coords="183,70,215,75,214,80,182,76"/>
<area shape="rect" href="classnz_1_1cu_strm_1_1_stream_manager.html#a1de1cf3aadea137faf90a2f9b4b7abe2" title="Acquires CUDA stream from pool using round&#45;robin scheduling." alt="" coords="463,39,648,81"/>
<area shape="poly" title=" " alt="" coords="415,77,447,73,448,78,416,83"/>
<area shape="rect" href="classnz_1_1cu_strm_1_1_stream_manager.html#adb1078a67c6e38932d7d58c2adb05ec0" title="Synchronizes CUDA stream execution until data writes complete." alt="" coords="463,105,648,148"/>
<area shape="poly" title=" " alt="" coords="416,104,448,109,447,114,415,109"/>
</map>
</div>

</div>
</div>
<h2 class="groupheader">Friends And Related Symbol Documentation</h2>
<a id="ab8eaa8e06861a868b7df1a9ee0616a1a" name="ab8eaa8e06861a868b7df1a9ee0616a1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8eaa8e06861a868b7df1a9ee0616a1a">&#9670;&#160;</a></span>operator&lt;&lt;</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DL_API std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classnz_1_1data_1_1_tensor.html">Tensor</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>tensor</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overloads the <code>&lt;&lt;</code> operator to print the tensor's data to an output stream. </p>
<p>This function is a friend of the <code><a class="el" href="classnz_1_1data_1_1_tensor.html" title="A class for representing and manipulating multidimensional arrays (tensors) in GPU memory.">Tensor</a></code> class and provides an overloaded version of the output stream operator (<code>&lt;&lt;</code>) to print the contents of a tensor to the specified output stream (e.g., <code>std::cout</code> or a file stream).</p>
<p>The tensor's data is first copied from GPU memory to host memory for printing, and then the data is printed in a 2D matrix format. Each row of the tensor is printed on a new line, and each element in a row is separated by a space. Each row is enclosed in square brackets.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>The output stream to which the tensor will be printed. </td></tr>
    <tr><td class="paramname">tensor</td><td>The tensor whose contents will be printed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The output stream (<code>os</code>) after the tensor has been printed, allowing for chaining of operations.</dd></dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>This operator works by accessing the tensor's private data members (e.g., <code>_data</code>) directly.</li>
<li>The tensor's data is assumed to be in a valid state (i.e., properly allocated in GPU memory) before printing.</li>
<li>The function copies the tensor's data from device (GPU) memory to host (CPU) memory using <code>cudaMemcpy</code>, which may introduce performance overhead for large tensors.</li>
</ul>
</dd></dl>
<div class="fragment"><div class="line">```cpp</div>
<div class="line"><a class="code hl_class" href="classnz_1_1data_1_1_tensor.html">Tensor</a> tensor({2, 3});</div>
<div class="line">tensor.<a class="code hl_function" href="#ad220de56b18c404611f07f2290cd7e9d">fill</a>(1.0f);  <span class="comment">// Fill the tensor with 1.0f</span></div>
<div class="line">std::cout &lt;&lt; tensor &lt;&lt; std::endl;  <span class="comment">// Prints the tensor to standard output in matrix format</span></div>
<div class="line">```</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="_tensor_8cu_source.html#l00039">39</a> of file <a class="el" href="_tensor_8cu_source.html">Tensor.cu</a>.</p>

</div>
</div>
<a id="a1ae147fdd4255f7d148aef41e3e436a9" name="a1ae147fdd4255f7d148aef41e3e436a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ae147fdd4255f7d148aef41e3e436a9">&#9670;&#160;</a></span>operator&gt;&gt;</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DL_API std::istream &amp; operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;</td>          <td class="paramname"><span class="paramname"><em>is</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classnz_1_1data_1_1_tensor.html">Tensor</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>tensor</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overloads the <code>&gt;&gt;</code> operator to read a tensor's data from an input stream. </p>
<p>This function is a friend of the <code><a class="el" href="classnz_1_1data_1_1_tensor.html" title="A class for representing and manipulating multidimensional arrays (tensors) in GPU memory.">Tensor</a></code> class and provides an overloaded version of the input stream operator (<code>&gt;&gt;</code>) to read the contents of a tensor from the specified input stream (e.g., <code>std::cin</code> or a file stream).</p>
<p>The function reads the tensor's data element by element from the input stream and stores the values in a temporary buffer. Once all the data has been read, it is copied from the host memory back into the tensor's GPU memory using <code>cudaMemcpy</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">is</td><td>The input stream from which the tensor's data will be read. </td></tr>
    <tr><td class="paramname">tensor</td><td>The tensor to which the data will be read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The input stream (<code>is</code>) after reading the tensor's data, allowing for chaining of operations.</dd></dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>This operator works by reading data from the input stream and storing it in a temporary buffer on the host.</li>
<li>The function assumes that the input data matches the size of the tensor. If the data is malformed or does not match, the behavior may be undefined.</li>
<li>After reading, the data is copied from host memory back into the tensor's GPU memory.</li>
</ul>
</dd></dl>
<div class="fragment"><div class="line">```cpp</div>
<div class="line"><a class="code hl_class" href="classnz_1_1data_1_1_tensor.html">Tensor</a> tensor({2, 3});</div>
<div class="line">std::cin &gt;&gt; tensor;  <span class="comment">// Reads the tensor&#39;s data from standard input</span></div>
<div class="line">```</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="_tensor_8cu_source.html#l00076">76</a> of file <a class="el" href="_tensor_8cu_source.html">Tensor.cu</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>D:/Users/Mgepahmge/Documents/C Program/NeuZephyr/include/NeuZephyr/<a class="el" href="_tensor_8cuh_source.html">Tensor.cuh</a></li>
<li>D:/Users/Mgepahmge/Documents/C Program/NeuZephyr/src/<a class="el" href="_tensor_8cu_source.html">Tensor.cu</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
